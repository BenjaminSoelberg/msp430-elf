/* Cypress Cy16 opcode support.  -*- C -*-
   Copyright (C) 2001, 2003, 2005 Red Hat, Inc.
   This file is part of CGEN.  */

/* This file is an addendum to cy16.cpu.  Heavy use of C code isn't
   appropriate in .cpu files, so it resides here.  This especially applies
   to assembly/disassembly where parsing/printing can be quite involved.
   Such things aren't really part of the specification of the cpu, per se,
   so .cpu files provide the general framework and .opc files handle the
   nitty-gritty details as necessary.

   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h".  */

/* -- opc.h */

/* Allows reason codes to be output when assembler errors occur.  */
#define CGEN_VERBOSE_ASSEMBLER_ERRORS

/* Override disassembly hashing - there are variable bits in the top
   byte of these instructions.  */
#define CGEN_DIS_HASH_SIZE 16
#define CGEN_DIS_HASH(buf,value) (((value) >> 12) & 0xf)

/* -- asm.c */
#include <ctype.h>

/* This parse handler exists solely for the purpose of issuing a range-check
   diagnostic. The ifield check reports the wrong range due to its encoding.  */

static const char *
parse_immed3 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      unsigned long *valuep)
{
  const char *errmsg = NULL;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_CY16_IMMED3,
			       &result_type, &value);

  if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
    {
      *valuep = value;
      if (errmsg == NULL && (*valuep < 1 || *valuep > 8))
	errmsg = "Immediate value must be in the range 1-8";
    }
  else
    *valuep = 1; /* cgen insert handler subtracts 1.  */
  
  return errmsg;
}

/* This parse handler exists to allow values in any range to be to be accepted
   by this signed operand.  All values are truncated (with sign extension) at
   16 bits.  This mimics the behavior of the QTASM assembler.  */

static const char *
parse_immediate (CGEN_CPU_DESC cd,
		 const char **strp,
		 int opindex,
		 long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, valuep);

  /* Extend the sign at 16 bits.  */
  *valuep = ((*valuep & ~(-1L << 16)) ^ (1 << 15)) - (1 << 15);

  return errmsg;
}

/* This parse handler is for the operand of a long (absolute) jump insn.  It
   accepts hardcoded addresses only.  Addresses involving labels are rejected
   and will be accepted by the short (relative) jump insn.  These may then be
   expanded to the long form again by assembler/linker relaxation.  */

static const char *
parse_long_jump_immed (CGEN_CPU_DESC cd,
		       const char **strp,
		       int opindex,
		       long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_CY16_LABEL_16,
			       &result_type, &value);
  if (errmsg == NULL && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
    {
      *valuep = value;
      return NULL;
    }
  /* Return any old message. It will never be seen anyway.  */
  return "Non-constant expression rejected for long jump";
}

/* This parse handler makes sure that a trailing "+<register>" is not consumed
   when parsing an expression which is an index to that base register.  */

static const char *
parse_pre_index (CGEN_CPU_DESC   cd,
		 const char **   strp,
		 int             opindex,
		 unsigned long * valuep)
{
  const char *errmsg;
  const char *cur;
  const char *plus;
  char *temp_str;
  const char *temp_end;
  int length;

  /* First scan the input string for ']' which marks the end of any potential
     expression, since this operand is part of an expression which is enclosed
     within [..].  If the ']' is not found, then fail right away since this
     can't be part of an index-with-indirect operand.  */
  cur = strchr (*strp, ']');
  if (cur == NULL)
    return "Missing ']'";

  /* Now scan backward for a '+' which could be part of a trailing '+<register>.
     Fail if not found, since an index-with-indirect operand must have at least
     one '+'.  */
  while (cur != *strp)
    {
      --cur;
      if (*cur == '+')
	break;
    }
  if (cur == *strp)
    return "Missing index or base register";

  /* Now see whether an address register name follows the '+'.  An address
     register is one of r8-r15, or sp.  */
  plus = cur;
  ++cur;
  if (*cur == 'r' || *cur == 'R')
    {
      char *end;
      long reg;

      ++cur;
      reg = strtol (cur, &end, 10);
      if (end == cur || reg < 8 || reg > 15)
	return "Missing base register";
      cur = end;
      
    }
  else if (*cur == 's' || *cur == 'S')
    {
      ++cur;
      if (*cur != 'p' && *cur != 'P')
	return "Missing base register";
      ++cur;
    }
  else
    return "Missing base register";

  /* Check that ']' is the next character, thus properly ending the
     index-with-indirect-operand.  */
  if (*cur != ']')
    return "Missing ']'";

  /* We have now identified an expression ending with '+<register>]'.  Parse
     everything except that suffix as an unsigned integer.  Make a temporary
     copy of the string and parse that.  */
  length = plus - * strp;
  temp_str = xmalloc (length + 1);
  memcpy (temp_str, * strp, length);
  temp_str[length] = '\0';
  temp_end = temp_str;
  errmsg = cgen_parse_unsigned_integer (cd, & temp_end, opindex, valuep);

  /* If the entire string was parsed successfully, then update strp.  */
  if (errmsg == NULL && temp_end - temp_str == length)
    * strp = plus;

  free (temp_str);
  return errmsg;
}

/* -- dis.c */
static void
print_long_jump_immed (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		       void * dis_info,
		       long value,
		       unsigned int attrs ATTRIBUTE_UNUSED,
		       bfd_vma pc ATTRIBUTE_UNUSED,
		       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  const unsigned long mask
    = ((1UL << 31) | ((1UL << 31) - 1));

  info->fprintf_func (info->stream, "0x%lx", (unsigned long) value & mask);
}

static void
print_immediate (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 void * dis_info,
		 long value,
		 unsigned int attrs ATTRIBUTE_UNUSED,
		 bfd_vma pc ATTRIBUTE_UNUSED,
		 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  const unsigned long mask
    = ((1UL << 31) | ((1UL << 31) - 1));

  info->fprintf_func (info->stream, "0x%lx", (unsigned long) value & mask);
}
/* -- */

