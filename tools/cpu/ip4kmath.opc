/* IP4KMATH opcode support.  -*- C -*-
   Copyright (C) 2000, 2001, 2004, 2005, 2006 Red Hat, Inc.
   This file is part of CGEN.  */

/*
   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h"
*/

/* -- opc.h */

/* #include "safe-ctype.h" */

/* Check applicability of instructions against machines.  */
#define CGEN_VALIDATE_INSN_SUPPORTED

/* Allows reason codes to be output when assembler errors occur.  */
#define CGEN_VERBOSE_ASSEMBLER_ERRORS

/* Override disassembly hashing - there are variable bits in the top
   byte of these instructions. Unluckily, it's not quite the same set of
   bits for both vector and scalar instructions, so we use the overlapping
   subset (26..22).  Unluckily also, the bits span two bytes.  */

#define CGEN_DIS_HASH_SIZE 32
#define CGEN_DIS_HASH(buf,value) ip4kmath_dis_hash (buf, value)

#define CGEN_ASM_HASH_SIZE 509
#define CGEN_ASM_HASH(insn) ip4kmath_asm_hash (insn)

extern unsigned int ip4kmath_dis_hash (const char *, CGEN_INSN_INT);
extern unsigned int ip4kmath_asm_hash (const char *);
extern int          ip4kmath_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);



/* -- opc.c */

#include "safe-ctype.h"

unsigned int
ip4kmath_dis_hash (const char *buf, CGEN_INSN_INT value ATTRIBUTE_UNUSED)
{
  unsigned int hash = (((buf[0] & 0x07) << 2) | ((buf[1] & 0xC0) >> 6));

  return hash % CGEN_DIS_HASH_SIZE;
}

/* A better hash function for instruction mnemonics.  */

unsigned int
ip4kmath_asm_hash (const char* insn)
{
  unsigned int hash;
  const char* m = insn;

  for (hash = 0; *m && ! ISSPACE (*m) && *m != '.'; m++)
    hash = (hash * 23) ^ (0x1F & TOLOWER (*m));

  /* printf ("%s %d\n", insn, (hash % CGEN_ASM_HASH_SIZE)); */

  return hash % CGEN_ASM_HASH_SIZE;
}

/* Special check to ensure that instruction is
   appropriate for machine with selected ISA.  */

int
ip4kmath_cgen_insn_supported (CGEN_CPU_DESC cd,
			      const CGEN_INSN *insn)
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);
  CGEN_ATTR_VALUE_BITSET_TYPE isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);

  /* If attributes are absent, assume no restriction.  */
  if (machs == 0)
    machs = ~0;

  return ((machs & cd->machs) && cgen_bitset_intersect_p (& isas, cd->isas));
}


/* -- asm.c */
/* Parse optional "[num]" vector broadcast element number.  */

static const char *
parse_vector_elements (CGEN_CPU_DESC cd,
		       const char **strp,
		       int opindex,
		       unsigned long *valuep)
{
  const char *errmsg;
  const char *str = *strp;
  unsigned long tempvalue;

  if (str[0] == '[')
    {
      str++;

      errmsg = cgen_parse_unsigned_integer (cd, & str, opindex, &tempvalue);
      if (errmsg)
	return errmsg;
      if (tempvalue > 7)
	return _("element number outside of legal 0..7 range");

      if (str[0] == ']')
	{
	  str ++;
	  *valuep =
	    0x01 | /* Set f-enable-v.  */
	    (tempvalue << 1);  /* Set f-ebits-v too.  */
	}
      else
	return _("missing `]'.");
    }
  else /* No [num] */
    /* Clear f-enable-v and incidentally f-ebits-v.  */
    *valuep = 0;

  /* Push strp past the operand.  */
  *strp = str;
  return NULL;
}

/* Parse "[part]" accumulator part number.  Enforce range limits.  */

static const char *
parse_acc_part (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (errmsg)
    return errmsg;
  if (*valuep > 2)
    return _("part number outside of legal 0..2 range");

  return NULL;
}

/* Parse shift selector.  Enforce range limits.  */

static const char *
parse_shift_selector (CGEN_CPU_DESC cd,
		      const char **strp,
		      int opindex,
		      unsigned long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (errmsg)
    return errmsg;
  if (*valuep > 1)
    {
      *valuep &= 1;
      return _("part number outside of legal 0..1 range");
    }

  return NULL;
}

/* Parse unsigned immediate value, being careful (hacky) to avoid
   eating a `++' that might be present.  */

static const char *
parse_offset_postinc (CGEN_CPU_DESC cd,
		      const char **strp,
		      int opindex,
		      unsigned long *valuep)
{
  const char *errmsg;
  char *plusplus;

  plusplus = strstr (*strp, "++");
  if (plusplus)
    *plusplus = 0;
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (plusplus)
    *plusplus = '+';

  return errmsg;
}

static const char *
parse_imm16 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;

  /* Parse %OP relocating operators.  */
  if (strncmp (*strp, "%data", 5) == 0)
    {
      *strp += 5;
      code = BFD_RELOC_IP4KMATH_DATA;
    }
  else if (strncmp (*strp, "%insn", 5) == 0)
    {
      *strp += 5;
      code = BFD_RELOC_IP4KMATH_INSN;
    }
  
  /* Parse %op operand.  */
  if (code != BFD_RELOC_NONE)
    {
      bfd_vma value;

      errmsg = cgen_parse_address (cd, strp, opindex, code, 
				   & result_type, & value);
      if ((errmsg == NULL) &&
	  (result_type != CGEN_PARSE_OPERAND_RESULT_QUEUED))
	errmsg = _("%operator operand is not a symbol");

      *valuep = value;
    }
  /* Parse as a number.  */
  else
    {
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);

      /* Truncate to sixteen bits to accept both signed and unsigned input.  */
      if (errmsg == NULL)
	*valuep &= 0xFFFF;
    }

  return errmsg;
}


/* -- dis.c */

#undef  CGEN_PRINT_INSN
#define CGEN_PRINT_INSN ip4kmath_print_insn_pair

/* The two insns (vector and scalar) are packed into one 64 bit vliw.  Each
   is 28 bits long and they are packed into the low order 56 bits of the vliw.
   
    | 8-bits unused | 28 bits vector insn | 28 bits scalar insn |

   This means that the boundary between the insns is at bit 28, which is
   not a byte boundary. The toolchain is not designed to handle this
   situation.  */

/* Replacement for default_print_insn, used to print a vector insn.
   This function extracts the vector insn from bits 55-28 of the vliw and
   places it into a 32 bit buffer before calling print_insn.  */

static int
ip4kmath_print_vector_insn (CGEN_CPU_DESC cd,
			    bfd_vma pc,
			    disassemble_info *info)
{
  unsigned char buf[CGEN_MAX_INSN_SIZE];
  int buflen;
  int status;
  int i;

  /* Attempt to read the base part of the insn.  */
  buflen = 5; /* insn spans 5 bytes */
  status = (*info->read_memory_func) (pc, buf, buflen, info);

  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }

  /* Shift the entire buffer left by 4 bits.  */
  --buflen;
  for (i = 0; i < buflen; ++i)
    {
      buf[i] <<= 4;
      buf[i] &= 0xf0;
      buf[i] |= (buf[i + 1] >> 4) & 0x0f;
    }

  return print_insn (cd, pc, info, buf, buflen);
}

/* Replacement for default_print_insn, used to print a scalar insn.
   This function extracts the scalar insn from bits 27-0 of the vliw and
   places it into a 32 bit buffer before calling print_insn.  */

static int
ip4kmath_print_scalar_insn (CGEN_CPU_DESC cd,
			    bfd_vma pc,
			    disassemble_info *info)
{
  unsigned char buf[CGEN_MAX_INSN_SIZE];
  int buflen;
  int status;

  /* Attempt to read the base part of the insn.  */
  buflen = 4; /* insn spans 4 bytes */
  status = (*info->read_memory_func) (pc, buf, buflen, info);

  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }

  /* Bits 32-29 of the insn are the low order 4 bits from the previous vector
     insn. Clear them before calling print insn.  */
  buf[0] &= 0x0f;

  return print_insn (cd, pc, info, buf, buflen);
}

/* This print_insn hook function is special, in that it reads *two*
   target instructions (one scalar, one vector).  It does this by
   CLOBBERING the "isa" field in the incoming CGEN_CPU_DESC struct,
   to filter out each ISA from consideration for the respective slot.  */

static int
ip4kmath_print_insn_pair (CGEN_CPU_DESC cd,
			  bfd_vma pc,
			  disassemble_info *info)
{
  int status;

  /* Disassemble the vector insn.  */
  cgen_bitset_clear (cd->isas);
  cgen_bitset_add (cd->isas, ISA_VECTOR);
  status = ip4kmath_print_vector_insn (cd, pc, info);

  if (status >= 0)
    {
      /* Separator.  */
      (*info->fprintf_func) (info->stream, " ; ");
  
      /* Disassemble the scalar insn.  */
      cgen_bitset_clear (cd->isas);
      cgen_bitset_add (cd->isas, ISA_SCALAR);
      status += ip4kmath_print_scalar_insn (cd, pc+4, info);
    }

  /* Error occurs if status != 8.  */
  if (status != 8)
    return -1;
  else
    return status;
}

static void
print_vector_elements (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		       void * dis_info,
		       long value,
		       unsigned int attrs ATTRIBUTE_UNUSED,
		       bfd_vma pc ATTRIBUTE_UNUSED,
		       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  if ((value & 0x01) != 0)  /* f-enable-v? */
    (*info->fprintf_func) (info->stream, "[%ld]", (value >> 1) & 0x07);
}

static void
print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 void * dis_info,
		 long value,
		 unsigned int attrs ATTRIBUTE_UNUSED,
		 bfd_vma pc ATTRIBUTE_UNUSED,
		 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "$%lx", value);
}

static void
print_decimal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	       void * dis_info,
	       long value,
	       unsigned int attrs ATTRIBUTE_UNUSED,
	       bfd_vma pc ATTRIBUTE_UNUSED,
	       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "%ld", value);
}

/* -- */
