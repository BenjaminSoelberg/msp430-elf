; Ubicom IP4K CPU description.  -*- Scheme -*-
; Copyright (C) 2000, 2001 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

(include "simplify.inc")

; define-arch must appear first
(define-arch
  (name ip4k) ; name of cpu family
  (comment "Ubicom IP")
  (default-alignment aligned)
  (insn-lsb0? #t)
  (machs ip4147)
  (isas ip4100)
)

; Instruction set parameters.

(define-isa
  (name ip4100)
  (comment "Ubicom IP4100 ISA")

  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
  ; (decode-assist (31 30 29 28 27))
)

; Cpu family definitions.

(define-cpu
  ; cpu names must be distinct from the architecture name and machine names.
  (name ip4100bf)
  (comment "Ubicom IP ip4100")
  (endian big)
  (word-bitsize 32)
)

(define-mach
  (name ip4147)
  (comment "Ubicom IP ip4147")
  (cpu ip4100bf)
  (bfd-name "ip4k")
)

; Model descriptions.

; The meaning of this value is wip but at the moment it's intended to describe
; the implementation (i.e. what -mtune=foo does in sparc gcc).
;
; Notes while wip:
; - format of pipeline entry:
;   (pipeline name (stage1-name ...) (stage2-name ...) ...)
;   The contents of a stage description is wip.
; - each mach must have at least one model
; - the default model must be the first one
;- maybe have `retire' support update total cycle count to handle current
;  parallel insn cycle counting problems

(define-model
  (name ip4147-200) (comment "IP4147-200") (attrs)
  (mach ip4147)

  ; XXX: IP4K: what to do here
  ; IP4K has 5 pipeline stages:
  ;        (PC) - fake stage; not counted
  ;        IF        insn fetch
  ;        AC        decode/address caluclatoin
  ;        DA        data access
  ;        EX        execution
  ;        WB        write back
  ;(pipeline p-non-mem "" () ((fetch) (decode) (execute) (writeback)))
  ;(pipeline p-mem "" () ((fetch) (decode) (execute) (memory) (writeback)))

  ; `state' is a list of variables for recording model state
  ; XXX: IP4K: what to do here
  (state
   ; bit mask of h-gr registers, =1 means value being loaded from memory
   (h-gr UINT)
   )

  ; XXX: IP4K: what to do here
  (unit u-exec "Execution Unit" ()
        1 1 ; issue done
        () ; state
        ((sr INT -1) (dr INT -1)) ; inputs
        ((dr INT -1)) ; outputs
        () ; profile action (default)
        )
  (unit u-cmp "Compare Unit" ()
        1 1 ; issue done
        () ; state
        ((src1 INT -1) (src2 INT -1)) ; inputs
        () ; outputs
        () ; profile action (default)
        )
  (unit u-mac "Multiply/Accumulate Unit" ()
        1 1 ; issue done
        () ; state
        ((src1 INT -1) (src2 INT -1)) ; inputs
        () ; outputs
        () ; profile action (default)
        )
  (unit u-cti "Branch Unit" ()
        1 1 ; issue done
        () ; state
        ((sr INT -1)) ; inputs
        ((pc)) ; outputs
        () ; profile action (default)
        )
  (unit u-load "Memory Load Unit" ()
        1 1 ; issue done
        () ; state
        ((sr INT)
         ;(ld-mem AI)
         ) ; inputs
        ((dr INT)) ; outputs
        () ; profile action (default)
        )
  (unit u-store "Memory Store Unit" ()
        1 1 ; issue done
        () ; state
        ((src1 INT) (src2 INT)) ; inputs
        () ; ((st-mem AI)) ; outputs
        () ; profile action (default)
        )
)


; Instruction fields.
;
; Attributes:
; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
; RESERVED: bits are not used to decode insn, must be all 0
; RELOC: there is a relocation associated with this field (experiment)

(define-pmacro (define-multi-ifield-op who bytes typename shift)
  (begin
    (define-multi-ifield
      (name (.str "f-" who "-imm7-" bytes))
      (comment (.str "7 bit immediate " typename))
      (attrs)
      (mode UINT)
      (subfields (.sym "f-" who "-imm7-t") (.sym "f-" who "-imm7-b"))
      (insert (sequence ()
                         (set (ifield (.sym "f-" who "-imm7-t"))
                          (and (srl
                                (ifield (.sym "f-" who "-imm7-" bytes))
			        (.eval (+ shift 5)))
                             (const #x3)))
                          (set (ifield (.sym "f-" who "-imm7-b"))
			    (and (srl
				(ifield (.sym "f-" who "-imm7-" bytes))
                                shift)
                            (const #x1f)))))
      (extract (sequence ()
                         (set (ifield (.sym "f-" who "-imm7-" bytes))
                           (sll (or (sll
                                 (ifield (.sym "f-" who "-imm7-t"))
                                 (const 5))
                               (ifield (.sym "f-" who "-imm7-b")))
                             (const shift)))))
    )
  )
)

(define-pmacro (f-11-bit-fields-op who myname base)
  (begin
    (dnf (.sym "f-" who)            (.str myname)                   () base   11)
    (dnf (.sym "f-" who "-bit10")   (.str who " top bit")           () base   1)
    (dnf (.sym "f-" who "-type")    (.str who " next 2 bits")       () (.eval (- base 1)) 2)
    (dnf (.sym "f-" who "-r")       (.str who " index register")    () (.eval (- base 6)) 5)
    (dnf (.sym "f-" who "-M")       (.str who " mode select bit")   () (.eval (- base 6)) 1)
    (df  (.sym "f-" who "-i4-1")    (.str who " 4-bit inc/dec 1")   () (.eval (- base 7)) 4 INT #f #f)
    (df  (.sym "f-" who "-i4-2")    (.str who " 4-bit inc/dec 2")   () (.eval (- base 7)) 4 INT
         ((value pc) (srl HI value (const 1)))
         ((value pc) (sll HI value (const 1))))
    (df  (.sym "f-" who "-i4-4")    (.str who " 4-bit inc/dec 4")   () (.eval (- base 7)) 4 INT
         ((value pc) (srl HI value (const 2)))
         ((value pc) (sll HI value (const 2))))
    (dnf (.sym "f-" who "-An")      (.str who " address reg")       () (.eval (- base 3)) 3)
    (df  (.sym "f-" who "-direct")  (.str who " direct address")    () (.eval (- base 3)) 8 UINT
         ((value pc) (srl UHI value (const 2)))
         ((value pc) (sll UHI value (const 2))))
    (df  (.sym "f-" who "-imm8")    (.str who " 8-bit immediate")   () (.eval (- base 3)) 8 INT #f #f)
    (dnf (.sym "f-" who "-imm7-t")  (.str who " imm7 i[6:5]")       () (.eval (- base 1)) 2)
    (dnf (.sym "f-" who "-imm7-b")  (.str who " imm7 i[4:0]")       () (.eval (- base 6)) 5)
    (define-multi-ifield-op who 1 "byte" 0)
    (define-multi-ifield-op who 2 "halfword" 1)
    (define-multi-ifield-op who 4 "word" 2)
  )
)

; f-d, f-d-bit10, f-d-type, f-d-r, f-d-M, f-d-i4-1, f-d-i4-2, f-d-i4-4,
; f-d-An, f-d-direct, f-d-imm8, f-d-imm7-t, f-d-imm7-b, f-d-imm7-1,
; f-d-imm7-2, f-d-imm7-4.
(f-11-bit-fields-op d destination 26)

; f-s1, f-s1-bit10, f-s1-type, f-s1-r, f-s1-M, f-s1-i4-1, f-s1-i4-2,
; f-s1-i4-4, f-s1-An, f-s1-direct, f-s1-imm8, f-s1-imm7-t, f-s1-imm7-b,
; f-s1-imm7-1, f-s1-imm7-2, f-s1-imm7-4,
(f-11-bit-fields-op s1 source-1 10)

(dnf f-op1       "op1"                    () 31 5)
(dnf f-op2       "op2"                    () 15 5)
(dnf f-bit26     "bit 26"                 () 26 1)
(dnf f-opext     "op extension"           () 25 5)
(dnf f-cond      "cond"                   () 26 4)
(dnf f-s2        "s2"                     () 15 5)
(df  f-imm16-1   "16-bit cmpi immediate"  () 26 16 INT #f #f)
(df  f-imm16-2   "16-bit movei immediate" () 15 16 INT #f #f)
; jmp offset - mask off lower 2 bits to ensure that offset is word-aligned
(df  f-o21       "21 bit rel-offset"      (PCREL-ADDR) 20 21 INT
     ((value pc) (srl SI (sub SI value pc) 2))
     ((value pc) (and SI (add SI (sll SI value 2) pc) (const #xfffffffc)))
)

; make top sub-field f-o23-21 signed so extract for multi-field will end up signed
(df  f-o23-21    "offset [23:21]"         () 26 3  INT #f #f)
(dnf f-o20-0     "offset [20:0]"          () 20 21)
(define-multi-ifield
  (name f-o24)
  (comment "24 bit relative offset")
  (attrs PCREL-ADDR)
  (mode INT)
  (subfields f-o23-21 f-o20-0)
  (encode (value pc) (sra SI (sub SI value pc) (const 2)))
  (decode (value pc) (add SI (sll SI value (const 2)) pc))
  (insert (sequence ()
                    (set (ifield f-o23-21)  (and (srl (ifield f-o24) (const 21)) (const #x7)))
                    (set (ifield f-o20-0)   (and (ifield f-o24) (const #x1fffff)))
                    ))
  (extract (sequence ()
                     (set (ifield f-o24) (or (ifield f-o20-0)
                                            (sll (ifield f-o23-21) (const 21))))
                     ))
)

; make top sub-field f-imm23-21 unsigned
(dnf f-imm23-21  "offset [23:21]"         () 26 3)
(define-multi-ifield
  (name f-imm24)
  (comment "24 bit immediate offset")
  (attrs)
  (mode UINT)
  (subfields f-imm23-21 f-o20-0)
  (insert (sequence ()
                    (set (ifield f-imm23-21) (and (srl (ifield f-imm24) (const 21)) (const #x7)))
                    (set (ifield f-o20-0)   (and (ifield f-imm24) (const #x1fffff)))
                    ))
  (extract (sequence ()
                     (set (ifield f-imm24) (or (ifield f-o20-0)
                                            (sll (ifield f-imm23-21) (const 21))))
                     ))
)

; make top sub-field f-o15-13 signed so extract for multi-field will end up signed
(df  f-o15-13    "offset [15:13]"         () 26 3  INT #f #f)
(dnf f-o12-8     "offset [12:8]"          () 20 5)
(dnf f-o7-5      "offset [7:5]"           () 10 3)
(dnf f-o4-0      "offset [4:0]"           () 4  5)
(define-multi-ifield
  (name f-o16)
  (comment "16 bit relative offset")
  (attrs)
  (mode INT)
  (subfields f-o15-13 f-o12-8 f-o7-5 f-o4-0)
  (encode (value pc) (sra SI value (const 2)))
  (decode (value pc) (sll SI value (const 2)))
  (insert (sequence ()
                    (set (ifield f-o15-13) (and (srl (ifield f-o16) (const 13)) (const #x7)))
                    (set (ifield f-o12-8)  (and (srl (ifield f-o16) (const 8)) (const #x1f)))
                    (set (ifield f-o7-5)   (and (srl (ifield f-o16) (const 5)) (const #x7)))
                    (set (ifield f-o4-0)   (and (ifield f-o16) (const #x1f)))
                    ))
  (extract (sequence ()
                     (set (ifield f-o16) (or (ifield f-o4-0)
                                             (or (sll (ifield f-o15-13) (const 13))
                                                 (or (sll (ifield f-o12-8) (const 8))
                                                     (sll (ifield f-o7-5) (const 5))))))
                     ))
)
(dnf f-An        "An register"            () 23 3)
(dnf f-Am        "Am register"            () 7  3)
(dnf f-Dn        "destination reg"        () 20 5)
(dnf f-bit5      "bit#"                   () 15 5)
(dnf f-P         "predication bit"        () 22 1)
(dnf f-C         "condition bit"          () 21 1)
(dnf f-int       "interrupt"              () 5  6)


; Enums.

; insn-op1: bits 31-27
(define-normal-insn-enum insn-op1 "insn format enums" () OP_ f-op1
  (
   (X0        #x00) (UNUSED_01 #x01) (X2        #x02) (UNUSED_03 #x03)
   (BSET      #x04) (BCLR      #x05) (UNUSED_06 #x06) (UNUSED_07 #x07)
   (AND_2     #x08) (AND_4     #x09) (OR_2      #x0a) (OR_4      #x0b) 
   (XOR_2     #x0c) (XOR_4     #x0d) (ADD_2     #x0e) (ADD_4     #x0f) 
   (ADDC      #x10) (SUB_2     #x11) (SUB_4     #x12) (SUBC      #x13)
   (UNUSED_14 #x14) (UNUSED_15 #x15) (UNUSED_16 #x16) (UNUSED_17 #x17) 
   (CMPI      #x18) (MOVEI     #x19) (JMP       #x1a) (CALL      #x1b) 
   (MOVEAI    #x1c) (UNUSED_1d #x1d) (CALLI     #x1e) (UNUSED_1f #x1f) 
  )
)

; insn-op2: bits 15-11
(define-normal-insn-enum insn-op2 "insn x0 opcode ext enums" () OPX0_ f-op2
  (
   (UNUSED_00 #x00) (SUSPEND   #x01) (UNUSED_02 #x02) (UNUSED_03 #x03) 
   (RET       #x04) (IERASE    #x05) (IREAD     #x06) (BKPT      #x07) 
   (UNUSED_08 #x08) (UNUSED_09 #x09) (NOT_4     #x0a) (NOT_2     #x0b)
   (MOVE_4    #x0c) (MOVE_2    #x0d) (UNUSED_0e #x0e) (MOVE_1    #x0f)
   (IWRITE    #x10) (UNUSED_11 #x11) (SETCSR    #x12) (UNUSED_13 #x13)
   (UNUSED_14 #x14) (EXT_2     #x15) (UNUSED_16 #x16) (EXT_1     #x17)
   (UNUSED_18 #x18) (UNUSED_19 #x19) (UNUSED_1a #x1a) (UNUSED_1b #x1b)
   (LEA_4     #x1c) (LEA_2     #x1d) (UNUSED_1e #x1e) (LEA_1     #x1f)
  )
)
; insn-opext: bits 25-21
(define-normal-insn-enum insn-opext "insn x2 opcode ext enums" () OPX2_ f-opext
  (
   (UNUSED_00 #x00) (MULS      #x01) (UNUSED_02 #x02) (MULU      #x03) 
   (UNUSED_04 #x04) (MULF      #x05) (BTST      #x06) (UNUSED_07 #x07) 
   (CRCGEN    #x08) (MAC       #x09) (UNUSED_0a #x0a) (UNUSED_0b #x0b) 
   (UNUSED_0c #x0c) (UNUSED_0d #x0d) (UNUSED_0e #x0e) (UNUSED_0f #x0f) 
   (LSL_4     #x10) (LSL_2     #x11) (LSR_4     #x12) (LSR_2     #x13)
   (ASR_4     #x14) (ASR_2     #x15) (BFEXTU    #x16) (UNUSED_17 #x17)
   (BFRVRS    #x18) (UNUSED_19 #x19) (SHFTD     #x1a) (UNUSED_1b #x1b)
   (MERGE     #x1c) (UNUSED_1d #x1d) (SHMRG_2   #x1e) (SHMRG_1   #x1f)
  )
)


; Hardware pieces.
; These entries list the elements of the raw hardware.
; They're also used to provide tables and other elements of the assembly
; language.

; global registers
(define-pmacro (defhw-reg me what sz c-name)
  (begin
    (define-hardware
      (name (.sym me))
      (comment what)
      (attrs VIRTUAL)
      (type register sz)
      (get () (c-call sz (.str "get_h_" c-name)))
      (set (newval) (c-call VOID (.str "set_h_" c-name) newval))
    )
  )
)

(defhw-reg h-global-control       "global control register"          USI  "glbl_ctl")
(defhw-reg h-mt-break             "multithreading break register"    USI  "mt_break")
(defhw-reg h-mt-active            "multithreading status register"   USI  "mt_active")
(defhw-reg h-mt-enable            "multithreading enable register"   USI  "mt_enable")
(defhw-reg h-mt-priority          "multithreading priority register" USI  "mt_priority")
(defhw-reg h-mt-schedule          "multithreading schedule register" USI  "mt_schedule")
(defhw-reg h-clock-control        "clock control register"           USI  "clock_ctl")
(defhw-reg h-irq-status-0         "interrupt status 0"               USI  "irq_status_0")
(defhw-reg h-irq-status-1         "interrupt status 1"               USI  "irq_status_1")

; per-context registers
; All registers but the PC are declared virtual and have get/set routines which are built-in.
; A context switch will replace the current register set similar to a register window (e.g. sparc).

(define-keyword
  (name data-names)
  (print-name h-dr)
  (prefix "")
  (values (d0 0) (d1 1) (d2 2) (d3 3) (d4 4) (d5 5) (d6 6) (d7 7)
          (d8 8) (d9 9) (d10 10) (d11 11) (d12 12) (d13 13) (d14 14) (d15 15)
          (d16 16) (d17 17) (d18 18) (d19 19) (d20 20) (d21 21) (d22 22) (d23 23)
          (d24 24) (d25 25) (d26 26) (d27 27) (d28 28) (d29 29) (d30 30) (d31 31))
)

(define-hardware
  (name h-dr)
  (comment "data registers")
  (attrs VIRTUAL)
  (type register SI(32))
  (indices extern-keyword data-names)
  (get (index) (c-call HI "get_h_dr" index))
  (set (index newval) (c-call VOID "set_h_dr" index newval))
)

(define-hardware
  (name h-s1-dr)
  (comment "source 1 data registers")
  (attrs VIRTUAL)
  (type register SI(32))
  (indices extern-keyword data-names)
  (get (index) (c-call HI "get_h_s1_dr" index))
  (set (index newval) (nop))  ; no setter for source register
)

(define-keyword
  (name addr-names)
  (print-name h-ar)
  (prefix "")
  (values (sp 7)
          (a0 0) (a1 1) (a2 2) (a3 3) (a4 4) (a5 5) (a6 6) (a7 7))
)

(define-hardware
  (name h-ar)
  (comment "address registers")
  (attrs VIRTUAL)
  (type register USI(8))
  (indices extern-keyword addr-names)
  (get (index) (c-call USI "get_h_ar" index))
  (set (index newval) (c-call VOID "set_h_ar" index newval))
)

; following handles deferring pre/post increment of actual address registers until
; after execution of instruction
(dnh h-ar-inc "address register pre/post increment values"
     () ; attributes
     (register USI(8))
     () ; indices
     () ; get
     () ; set
)

(dnh h-ar-inc-flag "address register pre/post increment flag"
     () ; attributes
     (register BI)
     () ; indices
     () ; get
     () ; set
)

(defhw-reg h-mac-hi      "high 16-bits of MAC result"            SI  "mac_hi")
(defhw-reg h-mac-lo      "low 32-bits of MAC result"             USI "mac_lo")
(defhw-reg h-src-3       "source 3 register"                     SI  "src_3")
(defhw-reg h-csr         "control & status register"             USI "csr")
(defhw-reg h-iread       "IREAD register"                        USI "iread")

(dnh h-pc "program counter" (PC PROFILE) (pc USI) () () ())

; condition-code bits
; need separate set per context

(define-hardware
  (name h-nbit-16)
  (comment "16-bit negative bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_nbit_16"))
  (set (newval) (c-call VOID "set_h_nbit_16" newval))
)

(define-hardware
  (name h-zbit-16)
  (comment "16-bit zero bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_zbit_16"))
  (set (newval) (c-call VOID "set_h_zbit_16" newval))
)

(define-hardware
  (name h-vbit-16)
  (comment "16-bit overflow bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_vbit_16"))
  (set (newval) (c-call VOID "set_h_vbit_16" newval))
)

(define-hardware
  (name h-cbit-16)
  (comment "16-bit carry bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_cbit_16"))
  (set (newval) (c-call VOID "set_h_cbit_16" newval))
)

(define-hardware
  (name h-nbit-32)
  (comment "32-bit negative bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_nbit_32"))
  (set (newval) (c-call VOID "set_h_nbit_32" newval))
)

(define-hardware
  (name h-zbit-32)
  (comment "32-bit zero bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_zbit_32"))
  (set (newval) (c-call VOID "set_h_zbit_32" newval))
)

(define-hardware
  (name h-vbit-32)
  (comment "32-bit overflow bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_vbit_32"))
  (set (newval) (c-call VOID "set_h_vbit_32" newval))
)

(define-hardware
  (name h-cbit-32)
  (comment "32-bit carry bit")
  (attrs VIRTUAL)
  (type register BI)
  (get () (c-call BI "get_h_cbit_32"))
  (set (newval) (c-call VOID "set_h_cbit_32" newval))
)

; fake hardware to help parse
(define-hardware
  (name h-cc)
  (comment "condition codes")
  (attrs)
  (type immediate (UINT 4))
  (values keyword ""
          (("f" 0)  ("lo" 1) ("cc" 1)  ("hs" 2)  ("cs" 2)  ("eq" 3)  ("ge" 4)  ("gt" 5) ("hi" 6)  
           ("le" 7)
           ("ls" 8) ("lt" 9) ("mi" 10) ("ne" 11) ("pl" 12) ("t" 13) ("vc" 14) ("vs" 15)))
)

(define-hardware
  (name h-C)
  (comment "condition code selection bit")
  (attrs)
  (type immediate (UINT 1))
  (values keyword "" (("" 1) (".s" 0) (".w" 1)))
)

; default to "true"
(define-hardware
  (name h-P)
  (comment "prediction bit")
  (attrs)
  (type immediate (UINT 1))
  (values keyword "" (("" 1) (".f" 0) (".t" 1)))
)


; Instruction Operands.
; These entries provide a layer between the assembler and the raw hardware
; description, and are used to refer to hardware elements in the semantic
; code.  Usually there's a bit of over-specification, but in more complicated
; instruction sets there isn't.

; 11 bit source/dest operand decoding.  there are the following different
; addressing modes:
;        - direct addressing: 8 bits
;        - indirect addressing
;        - indirect addressing with 7-bit unsigned offset
;        - indirect addressing with pre- or post-increment
;        - indirect addressing with indexing
;        - immediate value: 8 bits that sign extend to 16 bits
; the 11th bit it in these operands chooses between indirect with offset
; and other addressing modes.  in all indirect addressing modes, the first 3
; bits define which address register to use.  indirect with offset uses it's
; remaining 8 bits (unsigned) as the offset.  indirect with pre- or post-
; increment uses a signed 5 bit number.  indirect with index uses a 5 bit
; addressed data register.  direct addressing uses 8 bit address.
; note that all bit addresses are left shifted by one (as byte addresses
; are not typically accessed and are not addressable in the normal).

(dnop s2       "source register 2"            () h-dr      f-bit5)
(dnop src3     "src-3 register"               () h-src-3   f-nil)
(dnop offset24 "24-bit relative word offset"  () h-iaddr   f-o24)
(dnop An       "An register for call"         () h-ar      f-An)
(dnop cc       "condition code"               () h-cc      f-cond)
(dnop C        "condition code select bits"   () h-C       f-C)
(dnop P        "prediction bit"               () h-P       f-P)
(dnop Am       "Am register for calli"        () h-ar      f-Am)
(dnop Dn       "Dn reg for mac/mulu/mulf"     () h-dr      f-Dn)
(dnop interrupt "interrupt code"              () h-uint    f-int)
(dnop imm16-1  "16 bit immediate for cmpi"    () h-sint    f-imm16-1)
(dnop bit5     "5 bit number"                 () h-uint    f-bit5)
(dnop x-op2    "ignored secondary opcode"     () h-uint    f-op2)
(dnop x-bit26  "ignored bit 26"               () h-uint    f-bit26)
(dnop x-s1     "ignored s1 operand"           () h-uint    f-s1)
(dnop x-d      "ignored d operand"            () h-uint    f-d)
(dnop machi    "mac hi register"              () h-mac-hi  f-nil)
(dnop maclo    "mac lo register"              () h-mac-lo  f-nil)
(dnop irq-0    "irq status register 0"        () h-irq-status-0 f-nil)
(dnop irq-1    "irq status register 1"        () h-irq-status-1 f-nil)
(dnop iread    "iread register"               () h-iread   f-nil)
(dnop opc1     "primary opcode"               () h-uint    f-op1)
(dnop opc2     "secondary opcode"             () h-uint    f-op2)
(dnop An-inc   "An pre/post inc flag"         (SEM-ONLY)  h-ar-inc-flag  f-nil)

; Add special operand to handle operand 3 of restricted 3-operand instructions
(dndo imm-bit5
      SI
      (bit5)
      "#${bit5}"
      f-bit5
      (+ (f-bit26 0) bit5)
      (eq f-bit26 0)
      (zext SI bit5)
      () ; no setter
)

(dndo dyn-reg
      SI
      (s2)
      "${s2}"
      f-bit5
      (+ (f-bit26 1) s2)
      (eq f-bit26 1)
      (zext SI s2)
      () ; no setter
)

(define-anyof-operand
  (name op3)
  (comment "5-bit immediate value or dynamic register specification")
  (mode SI)
  (choices imm-bit5
	   dyn-reg
  )
)

; Support for conditional branches
(define-operand
  (name offset21)
  (comment "21-bit relative offset")
  (type h-iaddr)
  (index f-o21)
  (handlers (parse "offset21"))
)

(define-operand
  (name offset16)
  (comment "16-bit calli offset")
  (type h-sint)
  (index f-o16)
  (handlers (parse "offset16"))
)

; Support for 24-bit immediate for moveai instruction which may be constant or
; %hi(address)
(define-operand
  (name imm24)
  (comment "24-bit immediate")
  (type h-uint)
  (index f-imm24)
  (handlers (parse "imm24"))
)

; Condition code bits - 16-bit condition codes are separated from 32-bit condition codes
(dnop nbit-16 "16-bit negative    bit"      (SEM-ONLY) h-nbit-16 f-nil)
(dnop vbit-16 "16-bit overflow    bit"      (SEM-ONLY) h-vbit-16 f-nil)
(dnop zbit-16 "16-bit zero        bit"      (SEM-ONLY) h-zbit-16 f-nil)
(dnop cbit-16 "16-bit carry       bit"      (SEM-ONLY) h-cbit-16 f-nil)

(dnop nbit-32 "32-bit negative    bit"      (SEM-ONLY) h-nbit-32 f-nil)
(dnop vbit-32 "32-bit overflow    bit"      (SEM-ONLY) h-vbit-32 f-nil)
(dnop zbit-32 "32-bit zero        bit"      (SEM-ONLY) h-zbit-32 f-nil)
(dnop cbit-32 "32-bit carry       bit"      (SEM-ONLY) h-cbit-32 f-nil)

; source 1 operand

; source 1 imm7 unsigned operators - allow %lo() operator and validate range

(define-operand
  (name s1-imm7-1)
  (comment "7-bit immediate byte")
  (type h-uint)
  (index f-s1-imm7-1)
  (handlers (parse "imm7_1_s") (print "imm7"))
)

(define-operand
  (name s1-imm7-2)
  (comment "7-bit immediate halfword")
  (type h-uint)
  (index f-s1-imm7-2)
  (handlers (parse "imm7_2_s") (print "imm7"))
)

(define-operand
  (name s1-imm7-4)
  (comment "7-bit immediate word")
  (type h-uint)
  (index f-s1-imm7-4)
  (handlers (parse "imm7_4_s") (print "imm7"))
)

(define-operand
  (name s1-imm8)
  (comment "8-bit signed immediate")
  (type h-sint)
  (index f-s1-imm8)
  (handlers (parse "imm8"))
)

(dnop s1-An     "s1 address register"          () h-ar     f-s1-An)
(dnop s1-r      "s1 index register"            () h-s1-dr  f-s1-r)

; pre/post increment value for s1-An registers to be performed after insn execution
(dnop s1-An-inc "s1 An register pre/post inc"  (SEM-ONLY)  h-ar-inc  f-s1-An)

(define-pmacro (imm4-op who bytes)
  (begin
    (define-operand
      (name (.sym who "-i4-" bytes))
      (comment "4 bit signed-immediate value")
      (type h-sint)
      (index (.sym "f-" who "-i4-" bytes))
      (handlers (parse (.str "imm4_" bytes)) (print "imm4"))
    )
  )
)

; s1-i4-1, s1-i4-2, s1-i4-4
(imm4-op s1 1)
(imm4-op s1 2)
(imm4-op s1 4)

(define-pmacro (s1-indirect-op bytes rtype)
  (begin
    (dndo (.sym "s1-indirect-" bytes)
          rtype
          (s1-An)
          "(${s1-An})"
          f-s1
          (+ (f-s1-bit10 1) ((.sym "f-s1-imm7-" bytes) 0) s1-An)
          (andif (eq f-s1-bit10 1)
                 (eq (.sym "f-s1-imm7-" bytes) 0))
          (ext SI (mem rtype s1-An))
          () ; no setter
    )
  )
)

; s1-indirect-1, s1-indirect-2, s1-indirect-4
(s1-indirect-op 1 QI)
(s1-indirect-op 2 HI)
(s1-indirect-op 4 SI)

(define-pmacro (s1-indirect-with-offset-op bytes rtype)
  (begin
    (dndo (.sym "s1-indirect-with-offset-" bytes)
          rtype
          ((.sym "s1-imm7-" bytes) s1-An)
          (.str "${s1-imm7-" bytes "}(${s1-An})")
          f-s1
          (+ (f-s1-bit10 1) (.sym "s1-imm7-" bytes) s1-An)
          (andif (eq f-s1-bit10 1)
                 (ne (.sym "f-s1-imm7-" bytes) 0))
          (ext SI (mem rtype (add SI s1-An (.sym "s1-imm7-" bytes))))
          () ; no setter
    )
  )
)

; s1-indirect-with-offset-1, s1-indirect-with-offset-2,
; s1-indirect-with-offset-4
(s1-indirect-with-offset-op 1 QI)
(s1-indirect-with-offset-op 2 HI)
(s1-indirect-with-offset-op 4 SI)

(define-pmacro (s1-indirect-with-index-op bytes rtype)
  (begin
    (dndo (.sym "s1-indirect-with-index-" bytes)
          rtype
          (s1-r s1-An)
          "(${s1-An},${s1-r})"
          f-s1
          (+ (f-s1-bit10 0) (f-s1-type 3) s1-r s1-An)
          (andif (eq f-s1-bit10 0)
                 (eq f-s1-type 3))
          (ext SI (mem rtype (add s1-An (sll SI s1-r (srl SI bytes 1)))))
          () ; no setter
    )
  )
)

; s1-indirect-with-index-1, s1-indirect-with-index-2,
; s1-indirect-with-index-4
(s1-indirect-with-index-op 1 QI)
(s1-indirect-with-index-op 2 HI)
(s1-indirect-with-index-op 4 SI)

(define-pmacro (s1-indirect-with-post-increment-op bytes rtype)
  (begin
    (dndo (.sym "s1-indirect-with-post-increment-" bytes)
          rtype
          ((.sym "s1-i4-" bytes) s1-An)
          (.str "(${s1-An})${s1-i4-" bytes "}++")
          f-s1
          (+ (f-s1-bit10 0) (f-s1-type 2) (f-s1-M 0) (.sym "s1-i4-" bytes) s1-An)
          (andif (eq f-s1-bit10 0)
                 (eq f-s1-type 2)
                 (eq f-s1-M 0))
          (sequence SI ()
                    (set s1-An-inc (ext SI (.sym "s1-i4-" bytes)))
                    (set An-inc 1)
                    (ext SI (mem rtype s1-An)))
          () ; no setter
    )
  )
)

; s1-indirect-with-post-increment-1, s1-indirect-with-post-increment-2,
; s1-indirect-with-post-increment-4
(s1-indirect-with-post-increment-op 1 QI)
(s1-indirect-with-post-increment-op 2 HI)
(s1-indirect-with-post-increment-op 4 SI)

(define-pmacro (s1-indirect-with-pre-increment-op bytes rtype)
  (begin
    (dndo (.sym "s1-indirect-with-pre-increment-" bytes)
          rtype
          ((.sym "s1-i4-" bytes) s1-An)
          (.str "${s1-i4-" bytes "}(${s1-An})++")
          f-s1
          (+ (f-s1-bit10 0) (f-s1-type 2) (f-s1-M 1) (.sym "s1-i4-" bytes) s1-An)
          (andif (eq f-s1-bit10 0)
                 (eq f-s1-type 2)
                 (eq f-s1-M 1))
          (sequence SI ((SI Atmp))
                    (set s1-An-inc (ext SI (.sym "s1-i4-" bytes)))
                    (set An-inc 1)
                    (set Atmp (add s1-An s1-An-inc))
                    (ext SI (mem rtype Atmp)))
          () ; no setter
    )
  )
)

; s1-indirect-with-pre-increment-1, s1-indirect-with-pre-increment-2,
; s1-indirect-with-pre-increment-4
(s1-indirect-with-pre-increment-op 1 QI)
(s1-indirect-with-pre-increment-op 2 HI)
(s1-indirect-with-pre-increment-op 4 SI)

(define-operand
  (name s1-direct-addr)
  (attrs)
  (comment "s1 direct address")
  (type h-uint)
  (index f-s1-direct)
  (handlers (parse "s1_direct_addr") (print "direct_addr"))
)

(dndo s1-direct
      SI
      (s1-direct-addr)
      "${s1-direct-addr}"
      f-s1
      (+ (f-s1-bit10 0) (f-s1-type 1) s1-direct-addr)
      (andif (eq f-s1-bit10 0)
             (eq f-s1-type 1))
      (c-call SI "get_s1_direct_mem" s1-direct-addr)
      () ; no setter
)

(dndo s1-immediate
      SI
      (s1-imm8)
      "#${s1-imm8}"
      f-s1
      (+ (f-s1-bit10 0) (f-s1-type 0) s1-imm8)
      (andif (eq f-s1-bit10 0)
	     (eq f-s1-type 0))
      (ext SI s1-imm8)
      () ; no setter
)

(define-pmacro (s1-op bytes rtype)
  (begin
    (define-anyof-operand
      (name (.sym "s1-" bytes))
      (comment (.str "source 1 operand " bytes))
      (mode rtype)
                                        ; Each choice must have the same base-ifield.
      (choices s1-direct
	       s1-immediate
               (.sym "s1-indirect-with-index-" bytes)
               (.sym "s1-indirect-with-offset-" bytes)
	       (.sym "s1-indirect-" bytes)
               (.sym "s1-indirect-with-post-increment-" bytes)
               (.sym "s1-indirect-with-pre-increment-" bytes)
      )
    )
  )
)

; s1-1, s1-2, s1-4
(s1-op 1 QI)
(s1-op 2 HI)
(s1-op 4 SI)


; source 1 EA operand

(dndo s1-ea-indirect
      SI
      (s1-An)
      "(${s1-An})"
      f-s1
      (+ (f-s1-bit10 1) (f-s1-imm7-4 0) s1-An)
      (andif (eq f-s1-bit10 1)
             (eq f-s1-imm7-4 0))
      (add SI s1-An (const 0))
      () ; no setter
)

(define-pmacro (s1-ea-indirect-with-offset-op bytes)
  (begin
    (dndo (.sym "s1-ea-indirect-with-offset-" bytes)
	  SI
	  ((.sym "s1-imm7-" bytes) s1-An)
	  (.str "${s1-imm7-" bytes "}(${s1-An})")
	  f-s1
	  (+ (f-s1-bit10 1) (.sym "s1-imm7-" bytes) s1-An)
	  (andif (eq f-s1-bit10 1)
		 (ne (.sym "f-s1-imm7-" bytes) 0))
	  (add SI s1-An (.sym "s1-imm7-" bytes))
	  () ; no setter
    )
  )
)

; s1-ea-indirect-with-offset-1, s1-ea-indirect-with-offset-2, s1-ea-indirect-with-offset-4
(s1-ea-indirect-with-offset-op 1)
(s1-ea-indirect-with-offset-op 2)
(s1-ea-indirect-with-offset-op 4)

(define-pmacro (s1-ea-indirect-with-index-op bytes)
  (begin
    (dndo (.sym "s1-ea-indirect-with-index-" bytes)
	  SI
	  (s1-r s1-An)
	  "(${s1-An},${s1-r})"
	  f-s1
	  (+ (f-s1-bit10 0) (f-s1-type 3) s1-r s1-An)
	  (andif (eq f-s1-bit10 0)
		 (eq f-s1-type 3))
	  (add s1-An (sll SI s1-r (srl SI bytes 1)))
	  () ; no setter
    )
  )
)

; s1-ea-indirect-with-index-1, s1-ea-indirect-with-index-2, s1-ea-indirect-with-index-4
(s1-ea-indirect-with-index-op 1)
(s1-ea-indirect-with-index-op 2)
(s1-ea-indirect-with-index-op 4)

(define-pmacro (s1-ea-indirect-with-post-increment-op bytes)
  (begin
    (dndo (.sym "s1-ea-indirect-with-post-increment-" bytes)
	  SI
	  ((.sym "s1-i4-" bytes) s1-An)
	  (.str "(${s1-An})${s1-i4-" bytes "}++")
	  f-s1
	  (+ (f-s1-bit10 0) (f-s1-type 2) (f-s1-M 0) (.sym "s1-i4-" bytes) s1-An)
	  (andif (eq f-s1-bit10 0)
		 (eq f-s1-type 2)
		 (eq f-s1-M 0))
	  (sequence SI ()
		    (set s1-An-inc (ext SI (.sym "s1-i4-" bytes)))
                    (set An-inc 1)
		    (add SI s1-An (const 0)))
	  () ; no setter
    )
  )
)

; s1-ea-indirect-with-post-increment-1, s1-ea-indirect-with-post-increment-2, 
; s1-ea-indirect-with-post-increment-4
(s1-ea-indirect-with-post-increment-op 1)
(s1-ea-indirect-with-post-increment-op 2)
(s1-ea-indirect-with-post-increment-op 4)

(define-pmacro (s1-ea-indirect-with-pre-increment-op bytes)
  (begin
    (dndo (.sym "s1-ea-indirect-with-pre-increment-" bytes)
	  SI
	  ((.sym "s1-i4-" bytes) s1-An)
	  (.str "${s1-i4-" bytes "}(${s1-An})++")
	  f-s1
	  (+ (f-s1-bit10 0) (f-s1-type 2) (f-s1-M 1) (.sym "s1-i4-" bytes) s1-An)
	  (andif (eq f-s1-bit10 0)
		 (eq f-s1-type 2)
		 (eq f-s1-M 1))
	  (sequence SI ((SI Atmp))
		    (set s1-An-inc (.sym "s1-i4-" bytes))
                    (set An-inc 1)
		    (set Atmp (add s1-An s1-An-inc))
		    (add SI Atmp (const 0)))
	  () ; no setter
    )
  )
)

; s1-ea-indirect-with-pre-increment-1, s1-ea-indirect-with-pre-increment-2, 
; s1-ea-indirect-with-pre-increment-4
(s1-ea-indirect-with-pre-increment-op 1)
(s1-ea-indirect-with-pre-increment-op 2)
(s1-ea-indirect-with-pre-increment-op 4)

(dndo s1-ea-direct
      SI
      (s1-direct-addr)
      "${s1-direct-addr}"
      f-s1
      (+ (f-s1-bit10 0) (f-s1-type 1) s1-direct-addr)
      (andif (eq f-s1-bit10 0)
             (eq f-s1-type 1))
      (add SI s1-direct-addr (const 0))
      () ; no setter
)

(define-pmacro (s1-ea-op bytes)
  (begin
    (define-anyof-operand
      (name (.sym "s1-ea-" bytes))
      (comment "source 1 ea operand")
      (mode SI)
                                        ; Each choice must have the same base-ifield.
      (choices s1-ea-indirect
	       (.sym "s1-ea-indirect-with-offset-" bytes)
	       (.sym "s1-ea-indirect-with-index-" bytes)
	       (.sym "s1-ea-indirect-with-post-increment-" bytes)
	       (.sym "s1-ea-indirect-with-pre-increment-" bytes)
	       s1-ea-direct
      )
    )
  )
)

; s1-ea-1, s1-ea-2, s1-ea-4
(s1-ea-op 1)
(s1-ea-op 2)
(s1-ea-op 4)

; s1-pea
(define-anyof-operand
  (name s1-pea)
  (comment "source 1 pea operand")
  (mode SI)
					; Each choice must have the same base-ifield.
  (choices s1-ea-indirect
	   s1-ea-indirect-with-index-4
	   s1-ea-indirect-with-post-increment-4
	   s1-ea-indirect-with-pre-increment-4
	   s1-ea-indirect-with-offset-4
  )
)

; destination operand

; destination imm7 unsigned operators - allow %lo() operator and validate range

(define-operand
  (name d-imm7-1)
  (comment "7-bit immediate byte")
  (type h-uint)
  (index f-d-imm7-1)
  (handlers (parse "imm7_1_d") (print "imm7"))
)

(define-operand
  (name d-imm7-2)
  (comment "7-bit immediate halfword")
  (type h-uint)
  (index f-d-imm7-2)
  (handlers (parse "imm7_2_d") (print "imm7"))
)

(define-operand
  (name d-imm7-4)
  (comment "7-bit immediate word")
  (type h-uint)
  (index f-d-imm7-4)
  (handlers (parse "imm7_4_d") (print "imm7"))
)

(define-operand
  (name d-imm8)
  (comment "8-bit signed immediate")
  (type h-sint)
  (index f-d-imm8)
  (handlers (parse "imm8"))
)

(dnop d-An     "d address register"         () h-ar   f-d-An)
(dnop d-r      "d index register"           () h-dr   f-d-r)

; pre/post increment value for d-An registers to be performed after insn execution
(dnop d-An-inc "d An register pre/post inc" (SEM-ONLY) h-ar-inc f-d-An)


; d-i4-1, d-i4-2, d-i4-4
(imm4-op d 1)
(imm4-op d 2)
(imm4-op d 4)

(define-pmacro (d-indirect-op bytes rtype)
  (begin
    (dndo (.sym "d-indirect-" bytes)
          rtype
          (d-An)
          "(${d-An})"
          f-d
          (+ (f-d-bit10 1) ((.sym "f-d-imm7-" bytes) 0) d-An)
          (andif (eq f-d-bit10 1)
                 (eq (.sym "f-d-imm7-" bytes) 0))
          () ; no getter
          (set (mem rtype d-An) (trunc rtype newval))
    )
  )
)

; d-indirect-1, d-indirect-2, d-indirect-4
(d-indirect-op 1 QI)
(d-indirect-op 2 HI)
(d-indirect-op 4 SI)

(define-pmacro (d-indirect-with-offset-op bytes rtype)
  (begin
    (dndo (.sym "d-indirect-with-offset-" bytes)
          rtype
          ((.sym "d-imm7-" bytes) d-An)
          (.str "${d-imm7-" bytes "}(${d-An})")
          f-d
          (+ (f-d-bit10 1) (.sym "d-imm7-" bytes) d-An)
          (andif (eq f-d-bit10 1)
                 (ne (.sym "f-d-imm7-" bytes) 0))
          () ; no getter
          (set (mem rtype (add SI d-An (zext SI (.sym "d-imm7-" bytes)))) (trunc rtype newval))
    )
  )
)

; d-indirect-with-offset-1, d-indirect-with-offset-2,
; d-indirect-with-offset-4
(d-indirect-with-offset-op 1 QI)
(d-indirect-with-offset-op 2 HI)
(d-indirect-with-offset-op 4 SI)

(define-pmacro (d-indirect-with-index-op bytes rtype)
  (begin
    (dndo (.sym "d-indirect-with-index-" bytes)
          rtype
          (d-r d-An)
          "(${d-An},${d-r})"
          f-d
          (+ (f-d-bit10 0) (f-d-type 3) d-r d-An)
          (andif (eq f-d-bit10 0)
                 (eq f-d-type 3))
          () ; no getter
          (set (mem rtype (add d-An (sll SI d-r (srl SI bytes 1)))) (trunc rtype newval))
    )
  )
)

; d-indirect-with-index-1, d-indirect-with-index-2,
; d-indirect-with-index-4
(d-indirect-with-index-op 1 QI)
(d-indirect-with-index-op 2 HI)
(d-indirect-with-index-op 4 SI)

(define-pmacro (d-indirect-with-post-increment-op bytes rtype)
  (begin
    (dndo (.sym "d-indirect-with-post-increment-" bytes)
          rtype
          ((.sym "d-i4-" bytes) d-An)
          (.str "(${d-An})${d-i4-" bytes "}++")
          f-d
          (+ (f-d-bit10 0) (f-d-type 2) (f-d-M 0) (.sym "d-i4-" bytes) d-An)
          (andif (eq f-d-bit10 0)
                 (eq f-d-type 2)
                 (eq f-d-M 0))
          () ; no getter
          (sequence ()
                    (set d-An-inc (ext SI (.sym "d-i4-" bytes)))
                    (set An-inc 1)
                    (set (mem rtype d-An) (trunc rtype newval)))
    )
  )
)

; d-indirect-with-post-increment-1, d-indirect-with-post-increment-2,
; d-indirect-with-post-increment-4
(d-indirect-with-post-increment-op 1 QI)
(d-indirect-with-post-increment-op 2 HI)
(d-indirect-with-post-increment-op 4 SI)

(define-pmacro (d-indirect-with-pre-increment-op bytes rtype)
  (begin
    (dndo (.sym "d-indirect-with-pre-increment-" bytes)
          rtype
          ((.sym "d-i4-" bytes) d-An)
          (.str "${d-i4-" bytes "}(${d-An})++")
          f-d
          (+ (f-d-bit10 0) (f-d-type 2) (f-d-M 1) (.sym "d-i4-" bytes) d-An)
          (andif (eq f-d-bit10 0)
                 (eq f-d-type 2)
                 (eq f-d-M 1))
          () ; no getter
          (sequence ((SI Atmp))
                    (set d-An-inc (ext SI (.sym "d-i4-" bytes)))
                    (set An-inc 1)
                    (set Atmp (add d-An d-An-inc))
                    (set (mem rtype Atmp) (trunc rtype newval)))
    )
  )
)

; d-indirect-with-pre-increment-1, d-indirect-with-pre-increment-2,
; d-indirect-with-pre-increment-4
(d-indirect-with-pre-increment-op 1 QI)
(d-indirect-with-pre-increment-op 2 HI)
(d-indirect-with-pre-increment-op 4 SI)

(define-operand
  (name d-direct-addr)
  (attrs)
  (comment "dest direct address")
  (type h-uint)
  (index f-d-direct)
  (handlers (parse "d_direct_addr") (print "direct_addr"))
)

(dndo d-direct
      SI
      (d-direct-addr)
      "${d-direct-addr}"
      f-d
      (+ (f-d-bit10 0) (f-d-type 1) d-direct-addr)
      (andif (eq f-d-bit10 0)
             (eq f-d-type 1))
      () ; no getter
      (c-call VOID "set_d_direct_mem" d-direct-addr (zext SI newval))
)

(define-pmacro (d-immediate-op bytes rtype)
  (begin
    (dndo (.sym "d-immediate-" bytes)
          rtype
          (d-imm8)
          "#${d-imm8}"
          f-d
          (+ (f-d-bit10 0) (f-d-type 0) d-imm8)
          (andif (eq f-d-bit10 0)
                 (eq f-d-type 0))
          () ; no getter
          (nop)
    )
  )
)

; d-immediate-1, d-immediate-2, d-immediate-4
(d-immediate-op 1 QI)
(d-immediate-op 2 HI)
(d-immediate-op 4 SI)

(define-pmacro (d-op bytes rtype)
  (begin
    (define-anyof-operand
      (name (.sym "d-" bytes))
      (comment (.str "destination operand " bytes))
      (mode rtype)
                                        ; Each choice must have the same base-ifield.
      (choices d-direct 
               (.sym "d-immediate-" bytes)
               (.sym "d-indirect-with-index-" bytes)
               (.sym "d-indirect-with-offset-" bytes)
	       (.sym "d-indirect-" bytes)
               (.sym "d-indirect-with-post-increment-" bytes)
               (.sym "d-indirect-with-pre-increment-" bytes)
      )
    )
  )
)

; d-1, d-2, d-4
(d-op 1 QI)
(d-op 2 HI)
(d-op 4 SI)

; destination pea operand

(dndo d-pea-indirect
      SI
      (d-An)
      "(${d-An})"
      f-d
      (+ (f-d-bit10 1) (f-d-imm7-2 0) d-An)
      (andif (eq f-d-bit10 1)
             (eq f-d-imm7-2 0))
      (add SI d-An (const 0))
      () ; no setter
)

(dndo d-pea-indirect-with-offset
      SI
      (d-imm7-2 d-An)
      "${d-imm7-2}(${d-An})"
      f-d
      (+ (f-d-bit10 1) d-imm7-2 d-An)
      (andif (eq f-d-bit10 1)
             (ne f-d-imm7-2 0))
      (add SI d-An d-imm7-2)
      () ; no setter
)

(dndo d-pea-indirect-with-post-increment
      SI
      (d-i4-2 d-An)
      "(${d-An})${d-i4-2}++"
      f-d
      (+ (f-d-bit10 0) (f-d-type 2) (f-d-M 0) d-i4-2 d-An)
      (andif (eq f-d-bit10 0)
             (eq f-d-type 2)
             (eq f-d-M 0))
      (sequence SI ()
                (set d-An-inc d-i4-2)
		(set An-inc 1)
                (add d-An (const 0)))
      () ; no setter
)

(dndo d-pea-indirect-with-pre-increment
      SI
      (d-i4-2 d-An)
      "${d-i4-2}(${d-An})++"
      f-d
      (+ (f-d-bit10 0) (f-d-type 2) (f-d-M 1) d-i4-2 d-An)
      (andif (eq f-d-bit10 0)
             (eq f-d-type 2)
             (eq f-d-M 1))
      (sequence SI ((SI Atmp))
                (set d-An-inc d-i4-2)
		(set An-inc 1)
                (set Atmp (add d-An (ext SI d-i4-2)))
                (add SI Atmp (const 0)))
      () ; no setter
)

(dndo d-pea-indirect-with-index
      SI
      (d-r d-An)
      "(${d-An},${d-r})"
      f-d
      (+ (f-d-bit10 0) (f-d-type 3) d-r d-An)
      (andif (eq f-d-bit10 0)
	     (eq f-d-type 3))
      (add d-An (sll SI d-r 2))
      () ; no setter
)

(define-anyof-operand
  (name d-pea)
  (comment "destination 1 pea operand")
  (mode SI)
                                        ; Each choice must have the same base-ifield.
  (choices d-pea-indirect-with-index
           d-pea-indirect-with-offset
	   d-pea-indirect
           d-pea-indirect-with-post-increment
           d-pea-indirect-with-pre-increment
  )
)

; Support for %hi(foo) and %lo(foo), for movei insn
(define-operand
  (name imm16-2)
  (comment "16 bit immediate, for movei")
  (attrs)
  (type h-sint)
  (index f-imm16-2)
  (handlers (parse "imm16"))
)


; Instruction definitions.
;
; Notes while wip:
; - dni is a cover macro to the real "this is an instruction" keyword.
;   The syntax of the real one is yet to be determined.
;   At the lowest level (i.e. the "real" one) it will probably take a variable
;   list of arguments where each argument [perhaps after the standard three of
;   name, comment, attrs] is "(keyword arg-to-keyword)".  This syntax is simple
;   and yet completely upward extensible.  And given the macro facility, one
;   needn't code at that low a level so even though it'll be more verbose than
;   necessary it won't matter.  This same reasoning can be applied to most
;   types of entries in this file.
;
; - no instruction may reference s1 or d operands more than once because the
;   the pre-increment and post-increment forms change the value each access


; Useful macros
(define-pmacro (set-z x)
  (sequence ()
            (set zbit-16 (eq HI (trunc HI x) (const 0)))
            (set zbit-32 (eq SI x (const 0))))
       
)

(define-pmacro (set-n x)
  (sequence ()
            (set nbit-16 (lt HI (trunc HI x) (const 0)))
            (set nbit-32 (lt SI x (const 0))))
)
 
(define-pmacro (set-z-and-n x)
  (sequence ()
            (set-z x)
            (set-n x))
)

; for addc / subc only set z-flag - never clear
(define-pmacro (set-z-and-n-c x)
  (sequence ()
            (if (eq HI (trunc HI x) (const 0))
		(set zbit-16 1))
	    (if (eq SI x (const 0))
		(set zbit-32 1))
            (set-n x))
)

; and-2 / and-4 / or.2 / or.4 / xor.2 / xor.4
(define-pmacro (logical-op-3 op bytes opc dest src1 rtype)
  (begin
    (dni (.sym op "." bytes)
         (.str op "." bytes "d,s1,s2")
         ()
         (.str op "." bytes " ${" dest "},${" src1 "},$s2")
         (+ opc dest src1 s2)
         (sequence ((SI result))
                   (set result (op SI src1 s2))
                   (set dest result)
                   (set-z-and-n result))
         ()
         
    )
  )
)

(logical-op-3 and 2 OP_AND_2 d-2 s1-2 HI)
(logical-op-3 and 4 OP_AND_4 d-4 s1-4 SI)
(logical-op-3 or  2 OP_OR_2  d-2 s1-2 HI)
(logical-op-3 or  4 OP_OR_4  d-4 s1-4 SI)
(logical-op-3 xor 2 OP_XOR_2 d-2 s1-2 HI)
(logical-op-3 xor 4 OP_XOR_4 d-4 s1-4 SI)

; not.2 / not.4
(define-pmacro (not-op bytes op2c dest src1 rtype)
  (begin
    (dni (.sym not "." bytes)
         (.str "not." bytes " d,s")
         ()
         (.str "not." bytes " ${" dest "},${" src1 "}")
         (+ OP_X0 op2c dest src1)
         (sequence ((SI result))
                   (set result (inv SI src1))
                   (set dest result)
                   (set-z-and-n result))
         ()
    )
  )
)

(not-op 2 OPX0_NOT_2 d-2 s1-2 HI)
(not-op 4 OPX0_NOT_4 d-4 s1-4 SI)

; add-2 / add-4
(define-pmacro (add-op-3 bytes opc dest src1 rtype)
  (begin
    (dni (.sym "add." bytes)
         (.str "add." bytes "d,s1,s2")
         ()
         (.str "add." bytes " ${" dest "},${" src1 "},$s2")
         (+ opc dest src1 s2)
         (sequence ((SI result) (SI s1))
		   (set s1 (ext SI src1))
                   (set vbit-32 (add-oflag SI s1 s2 (const 0)))
                   (set cbit-32 (add-cflag SI s1 s2 (const 0)))
                   (set vbit-16 (add-oflag HI (trunc HI s1) (trunc HI s2) (const 0)))
                   (set cbit-16 (add-cflag HI (trunc HI s1) (trunc HI s2) (const 0)))
                   (set result (add SI s1 s2))
                   (set dest result)
                   (set-z-and-n result))
         ()
    )
  )
)

(add-op-3 2 OP_ADD_2 d-2 s1-2 HI)
(add-op-3 4 OP_ADD_4 d-4 s1-4 SI)

; sub-2 / sub-4
(define-pmacro (sub-op-3 bytes opc dest src1 rtype)
  (begin
    (dni (.sym "sub." bytes)
         (.str "sub." bytes "d,s1,s2")
         ()
         (.str "sub." bytes " ${" dest "},${" src1 "},$s2")
         (+ opc dest src1 s2)
         (sequence ((SI result) (SI s1))
		   (set s1 (ext SI src1))
                   (set vbit-32 (sub-oflag SI s1 s2 (const 0)))
                   (set cbit-32 (not (sub-cflag SI s1 s2 (const 0))))
                   (set vbit-16 (sub-oflag HI (trunc HI s1) (trunc HI s2) (const 0)))
                   (set cbit-16 (not (sub-cflag HI (trunc HI s1) (trunc HI s2) (const 0))))
                   (set result (sub SI s1 s2))
                   (set dest result)
                   (set-z-and-n result))
         ()
    )
  )
)

(sub-op-3 2 OP_SUB_2 d-2 s1-2 HI)
(sub-op-3 4 OP_SUB_4 d-4 s1-4 SI)


; addc
(dni (addc)
     ("addc d,s1,s2")
     ()
     ("addc ${d-4},${s1-4},$s2")
     (+ OP_ADDC d-4 s1-4 s2)
     (sequence ((SI result) (SI s1))
	       (set s1 s1-4)
	       (set vbit-16 (add-oflag HI (trunc HI s1) (trunc HI s2) cbit-32))
	       (set cbit-16 (add-cflag HI (trunc HI s1) (trunc HI s2) cbit-32))
	       (set vbit-32 (add-oflag SI s1 s2 cbit-32))
	       (set result (addc SI s1 s2 cbit-32))
	       (set cbit-32 (add-cflag SI s1 s2 cbit-32))
	       (set d-4 result)
	       (set-z-and-n-c result))
     ()
         
)

; subc
(dni (subc)
     ("subc d,s1,s2")
     ()
     ("subc ${d-4},${s1-4},$s2")
     (+ OP_SUBC d-4 s1-4 s2)
     (sequence ((SI result) (SI s1) (BI borrow))
	       (set borrow (not cbit-32))
	       (set s1 s1-4)
	       (set vbit-16 (sub-oflag HI (trunc HI s1) (trunc HI s2) borrow))
	       (set cbit-16 (not (sub-cflag HI (trunc HI s1) (trunc HI s2) borrow)))
	       (set vbit-32 (sub-oflag SI s1 s2 borrow))
	       (set cbit-32 (not (sub-cflag SI s1 s2 borrow)))
	       (set result (subc SI s1 s2 borrow))
	       (set d-4 result)
	       (set-z-and-n-c result))
     ()
)

; cmpi
(dni (cmpi)
     ("cmpi s,#imm-16")
     ()
     ("cmpi ${s1-2},#${imm16-1}")
     (+ OP_CMPI s1-2 imm16-1)
     (sequence ((SI tmp) (SI s1))
	       (set s1 s1-2)
               (set vbit-16 (sub-oflag HI (trunc HI s1) imm16-1 (const 0)))
               (set cbit-16 (not (sub-cflag HI (trunc HI s1) imm16-1 (const 0))))
               (set vbit-32 (sub-oflag SI s1 (ext SI imm16-1) (const 0)))
               (set cbit-32 (not (sub-cflag SI s1 (ext SI imm16-1) (const 0))))
               (set tmp (sub SI s1 (ext SI imm16-1)))
               (set-z-and-n tmp))
     ()
)


; lea.1, lea.2, lea.4
(define-pmacro (lea-op bytes op2 dest source)
  (begin
    (dni (.sym "lea." bytes)
	 (.str "lea." bytes " d,s1")
	 ()
	 (.str "lea." bytes " ${" dest "},${" source "}")
	 (+ OP_X0 op2 dest source)
	 (set dest source)
	 ()
    )
  )
)

(lea-op 1 OPX0_LEA_1 d-1 s1-ea-1)
(lea-op 2 OPX0_LEA_2 d-2 s1-ea-2)
(lea-op 4 OPX0_LEA_4 d-4 s1-ea-4)

; muls
(dni (muls)
     ("muls s1,op3")
     ()
     ("muls ${s1-2},${op3}")
     (+ OP_X2 OPX2_MULS (f-Dn 0) s1-2 op3)
     (sequence ((SI result) (SI tmp1) (SI tmp2))
	       (set tmp1 (ext SI (trunc HI s1-2)))
	       (set tmp2 (ext SI (trunc HI op3)))
	       (set result (mul tmp1 tmp2))
	       (set machi (ext SI (trunc HI (sra result (const 31)))))
	       (set maclo result)
               (c-call VOID "finish_multiply"))
      ()
)

; mulu
(dni (mulu)
     ("mulu s1,op3")
     ()
     ("mulu ${s1-2},${op3}")
     (+ OP_X2 OPX2_MULU (f-Dn 0) s1-2 op3)
     (sequence ((USI result) (USI tmp1) (USI tmp2))
	       (set tmp1 (and USI s1-2 (const #xffff)))
	       (set tmp2 (and USI op3 (const #xffff)))
	       (set result (mul tmp1 tmp2))
	       (set machi (const 0))
	       (set maclo result)
               (c-call VOID "finish_multiply"))
     ()
)

; mulf
(dni (mulf)
     ("mulf s1,op3")
     ()
     ("mulf ${s1-2},${op3}")
     (+ OP_X2 OPX2_MULF (f-Dn 0) s1-2 op3)
     (sequence ((SI result) (SI tmp1) (SI tmp2))
	       (set tmp1 (ext SI (trunc HI s1-2)))
	       (set tmp2 (ext SI (trunc HI op3)))
	       (if (or (ne tmp1 (const #xffff8000))
		       (ne tmp2 (const #xffff8000)))
		   (set result (sll (mul tmp1 tmp2) (const 1)))
		   (set result (const #x7fffffff))
		   )
	       (set machi (ext SI (trunc HI (sra result (const 31)))))
	       (set maclo result)
               (c-call VOID "finish_multiply"))
     ()
)

; mac
(dni (mac)
     ("mac s1,op3")
     ()
     ("mac ${s1-2},${op3}")
     (+ OP_X2 OPX2_MAC (f-Dn 0) s1-2 op3)
     (sequence ((SI result) (HI resulthi) (SI tmp1) (SI tmp2) (BI carry) (BI ov))
	       (set tmp1 (ext SI (trunc HI s1-2)))
	       (set tmp2 (ext SI (trunc HI op3)))
	       (if (or (ne tmp1 (const #xffff8000))
		       (ne tmp2 (const #xffff8000)))
		   (set result (sll (mul tmp1 tmp2) (const 1)))
		   (set result (const #x7fffffff))
		   )
	       (set resulthi (trunc HI (sra result (const 31))))
	       (set carry (add-cflag maclo result (const 0)))
	       (set maclo (add maclo result))
	       (set ov (add-oflag HI machi resulthi carry))
	       (set machi (ext SI (addc HI machi resulthi carry)))
	       (if (ne ov (const 0))
		   (if (lt resulthi (const 0))
		       (sequence ()
				 (set machi (const #xffff8000))
				 (set maclo (const 0)))
		       (sequence ()
				 (set machi (const #x7fff))
				 (set maclo (const #xffffffff)))
	           )
	       )
               (c-call VOID "finish_multiply"))
     ()
)

; lsr.2 / lsr.4 / lsl.2 / lsl.4
(define-pmacro (shift-op op bytes opc cgenop src1)
  (begin
    (dni (.sym op "." bytes)
         (.str op "." bytes " d,s,op3")
         ()
         (.str op "." bytes " ${Dn},${" src1 "},${op3}")
         (+ OP_X2 opc Dn op3 src1)
         (sequence ((SI result) (SI s1))
		   (set s1 src1)
                   (set result (cgenop SI s1 (and USI op3 (const #x1f))))
                   (set Dn result)
                   (set-z-and-n result))
         ()
    )
  )
)

(shift-op lsr 2 OPX2_LSR_2 srl s1-2)
(shift-op lsr 4 OPX2_LSR_4 srl s1-4)
(shift-op lsl 2 OPX2_LSL_2 sll s1-2)
(shift-op lsl 4 OPX2_LSL_4 sll s1-4)
(shift-op asr 2 OPX2_ASR_2 sra s1-2)
(shift-op asr 4 OPX2_ASR_4 sra s1-4)

; shftd
(dni (shftd)
     ("shftd d,s1,op3")
     ()
     ("shftd ${Dn},${s1-4},${op3}")
     (+ OP_X2 OPX2_SHFTD Dn s1-4 op3)
     (sequence ((SI tmp) (SI result) (SI s1) (SI shift))
	       (set s1 s1-4)
	       (set shift (and src3 (const #x3f)))
	       (if (gt shift (const 31))
		   (set result (srl SI op3 (sub shift (const 32))))
		   (if (gt shift (const 0))
		       (sequence ()
				 (set tmp (srl s1 src3))
				 (set result (or tmp (sll op3 (sub (const 32) shift)))))
		       (set result s1)
		       )
		   )
	       (set Dn result)
	       (set-z-and-n result))
     ()
)

; merge
(dni (merge)
     (.str "merge d,s1,op3")
     ()
     ("merge ${Dn},${s1-4},${op3}")
     (+ OP_X2 OPX2_MERGE Dn s1-4 op3)
     (sequence ((SI tmp1) (SI tmp2) (SI result))
	       (set tmp1 (and SI s1-4 src3))
	       (set tmp2 (and SI op3 (inv SI src3)))
	       (set result (or SI tmp1 tmp2))
	       (set Dn result)
	       (set-z-and-n result))
     ()
)

; bfrvrs
(dni (bfrvrs)
     ("bfrvrs d,s1,op3")
     ()
     ("bfrvrs ${Dn},${s1-4},${op3}")
     (+ OP_X2 OPX2_BFRVRS Dn s1-4 op3)
     (sequence ((SI result))
	       (set result (c-call SI "bfrvrs" op3 s1-4))
	       (set Dn result)
	       (set-z-and-n result))
     ()
)

; bfextu
(dni (bfextu)
     ("bfextu d,s1,op3")
     ()
     ("bfextu ${Dn},${s1-4},${op3}")
     (+ OP_X2 OPX2_BFEXTU Dn s1-4 op3)
     (sequence ((SI tmp) (SI numzeroes) (SI start))
	       (set start (and SI (srl SI op3 (const 8)) (const #x1f)))
	       (set tmp (srl SI s1-4 start))
	       (set numzeroes (sub SI (const 32) (and SI op3 (const #x1f))))
	       (if (eq numzeroes (const 32))
		   (set tmp (const 0))
		   (sequence ()
			     (set tmp (sll SI tmp numzeroes))
			     (set tmp (srl SI tmp numzeroes))
			     )
		   )
	       (set Dn tmp)
	       (set-z-and-n tmp))
     ()
)

; crcgen
(dni (crcgen)
     ("crcgen d,s1,op3")
     ()
     ("crcgen ${Dn},${s1-1},${op3}")
     (+ OP_X2 OPX2_CRCGEN Dn s1-1 op3)
     (sequence ()
               (set Dn (c-call USI "crcgen" s1-1 op3)))
     ()
)

; shmrg.1 / shmrg.2
(define-pmacro (shmrg-op bytes opc src1)
  (begin
    (dni (.sym "shmrg." bytes)
         (.str "shmrg." bytes " d,s,op3")
         ()
         (.str "shmrg." bytes " ${Dn},${" src1 "},${op3}")
         (+ OP_X2 opc Dn op3 src1)
         (sequence ((SI result) (SI s1) (SI shift) (SI numzeroes))
		   (set shift (sll SI bytes 3))
		   (set numzeroes (sub SI 32 shift))
		   (set s1 (srl SI (sll SI op3 numzeroes) numzeroes))
                   (set result (or SI s1 (sll SI src1 shift)))
                   (set Dn result)
                   (set-z-and-n result))
         ()
    )
  )
)

(shmrg-op 1 OPX2_SHMRG_1 s1-1)
(shmrg-op 2 OPX2_SHMRG_2 s1-2)

; btst
(dni (btst)
     ("btst d,s1,op3")
     ()
     ("btst ${s1-4},${op3}")
     (+ OP_X2 OPX2_BTST (f-Dn 0) s1-4 op3)
     (sequence ((SI mask))
	       (set mask (sll SI (const 1) (and USI op3 (const #x1f))))
	       (set zbit-32 (eq (and SI mask s1-4) 0))
	       (set zbit-16 zbit-32))
     ()
)               

; bset
(dni (bset)
     ("bset d,s1,#bit_number")
     ()
     ("bset ${d-4},${s1-4},#${bit5}")
     (+ OP_BSET d-4 bit5 s1-4)
     (sequence ((SI mask) (SI s1))
	       (set s1 s1-4)
               (set mask (sll SI (const 1) (zext SI bit5)))
               (set zbit-32 (eq (and SI mask s1) 0))
	       (set zbit-16 zbit-32)
               (set d-4 (or SI s1 mask)))
     ()
)               

; bclr
(dni (bclr)
     ("bclr d,s1,#bit_number")
     ()
     ("bclr ${d-4},${s1-4},#${bit5}")
     (+ OP_BCLR d-4 bit5 s1-4)
     (sequence ((SI mask) (SI s1))
	       (set s1 s1-4)
               (set mask (sll SI (const 1) (zext SI bit5)))
               (set zbit-32 (eq (and SI mask s1) 0))
	       (set zbit-16 zbit-32)
               (set d-4 (and SI s1 (inv SI mask))))
     ()
)               

; movei
(dni (movei)
     ("movei d,#imm-16")
     ()
     ("movei ${d-2},#${imm16-2}")
     (+ OP_MOVEI d-2 imm16-2)
     (sequence ((SI result))
               (set result (ext SI (trunc HI imm16-2)))
               (set d-2 result))
     ()
)

; moveai
(dni (moveai)
     ("moveai An,#imm-24")
     ()
     ("moveai ${An},#${imm24}")
     (+ OP_MOVEAI An imm24)
     (sequence ()
	       (set An (sll (zext SI imm24) 7)))
     ()
)

; ext.1
(dni (ext.1)
     ("ext.1 d,s")
     ()
     ("ext.1 ${d-1},${s1-1}")
     (+ OP_X0 OPX0_EXT_1 d-1 s1-1)
     (sequence ((SI result))
               (set result (ext SI (trunc QI s1-1)))
               (set d-1 result)
               (set-z-and-n result))
     ()
)

; ext.2
(dni (ext.2)
     ("ext.2 d,s")
     ()
     ("ext.2 ${d-2},${s1-2}")
     (+ OP_X0 OPX0_EXT_2 d-2 s1-2)
     (sequence ((SI result))
               (set result (ext SI (trunc HI s1-2)))
               (set d-2 result)
               (set-z-and-n result))
     ()
)

; move.1
(dni (move.1)
     ("move.1 d,s")
     ()
     ("move.1 ${d-1},${s1-1}")
     (+ OP_X0 OPX0_MOVE_1 d-1 s1-1)
     (sequence ((SI result))
               (set result (zext SI (trunc QI s1-1)))
               (set d-1 result)
               (set-z-and-n result))
     ()
)

; move.2
(dni (move.2)
     ("move.2 d,s")
     ()
     ("move.2 ${d-2},${s1-2}")
     (+ OP_X0 OPX0_MOVE_2 d-2 s1-2)
     (sequence ((SI result))
               (set result (zext SI (trunc HI s1-2)))
               (set d-2 result)
               (set-z-and-n result))
     ()
)

; move.4
(dni (move.4)
     ("move.4 d,s")
     ()
     ("move.4 ${d-4},${s1-4}")
     (+ OP_X0 OPX0_MOVE_4 d-4 s1-4)
     (sequence ((SI result))
               (set result s1-4)
               (set d-4 result)
               (set-z-and-n result))
     ()
)

; nop virtual insn equivalent to move.4 #0,#0.  The virtual insn by-passes a problem cgen has 
; emitting insns with derived operands
(dni (nop-insn) 
     ("nop-insn")
     ()
     ("__nop__")
     (+ OP_MOVEI (f-d 0) (f-imm16-2 0))
     (sequence ()
	       (nop))
     ()
)

; jmp<cc>
(dni (jmpcc)
     ("jmp<cc>.C.T/F offset")
     ()
     ("jmp${cc}${C}${P} $offset21")
     (+ OP_JMP cc C P offset21)
     (sequence ((SI mask))
               (set mask (c-call SI "check_mask" C cc))
               (if (eq mask (const 0))
                   (nop)
                   (set pc offset21)))
     ()
)

; call
(dni (call)
     ("call An,offset")
     ()
     ("call $An,$offset24")
     (+ OP_CALL An offset24)
     (sequence ()
               (set An (add SI pc (const 4)))
               (set pc offset24))
     ()
)

; calli
(dni (calli)
     ("calli An,offset(Am)")
     ()
     ("calli ${An},${offset16}(${Am})")
     (+ OP_CALLI (f-bit5 0) Am An offset16)
     (sequence ((SI tmp))
               (set tmp (add SI pc (const 4)))
               (set pc (add SI Am offset16))
	       (set An tmp))
     ()
)

; ret
(dni (ret)
     ("ret s1")
     ()
     ("ret ${s1-4}")
     (+ OP_X0 OPX0_RET (f-d 0) s1-4)
     (set pc s1-4)
     ()
)

; suspend
(dni (suspend)
     ("suspend")
     ()
     ("suspend")
     (+ OP_X0 OPX0_SUSPEND (f-d 0) (f-s1 0))
     (sequence ()
               (c-call VOID "suspend"))
     ()
)

; bkpt
(dni (bkpt)
     ("bkpt s1")
     ()
     ("bkpt ${s1-4}")
     (+ OP_X0 OPX0_BKPT (f-d 0) s1-4)
     (sequence ()
               (c-call VOID "bkpt" s1-4))
     ()

)

; setcsr
(dni (setcsr)
     ("setcsr s1")
     ()
     ("setcsr ${s1-4}")
     (+ OP_X0 OPX0_SETCSR (f-d 0) s1-4)
     (sequence ()
               (c-call VOID "setcsr" s1-4))
     ()
)

; nop
(dnmi (nop) 
      ("nop")
      ()
      ("nop")
      (emit nop-insn)
)
             
; iwrite
(dni (iwrite)
     ("iwrite pea_d,s1")
     ()
     ("iwrite ${d-pea},${s1-2}")
     (+ OP_X0 OPX0_IWRITE d-pea s1-2)
     (sequence ()
               (c-call VOID "iwrite" d-pea s1-2))
     ()
)

; iread - note that the single operand actually refers to the program space, however,
;         the format and calculations of the address are identical to that of s1-ea-2
(dni (iread)
     ("iread pea_s1")
     ()
     ("iread ${s1-pea}")
     (+ OP_X0 OPX0_IREAD (f-d 0) s1-pea)
     (sequence ()
               (set iread (c-call USI "iread" s1-pea)))
     ()
)
                                         
; ierase
(dni (ierase)
     ("ierase pea_d")
     ()
     ("ierase ${d-pea}")
     (+ OP_X0 OPX0_IERASE d-pea (f-s1 0))
     (sequence ()
               (c-call VOID "ierase" d-pea))
     ()
)

; unused instructions
(define-pmacro (unused-op opc opc2 code)
  (begin
    (dni (.sym "unused." code)
         (.str "UNUSED " code)
         (NO-DIS)
         (.str "__unused__" code)
         (+ opc opc2 x-d x-s1)
	 (sequence ()
		   (c-call VOID "unused_insn"))
         ()
    )
  )
)

(define-pmacro (unused-op2 opc opc2 code)
  (begin
    (dni (.sym "unused." code)
         (.str "UNUSED " code)
         (NO-DIS)
         (.str "__unused__" code)
         (+ opc opc2 Dn x-bit26 x-op2 x-s1)
	 (sequence ()
		   (c-call VOID "unused_insn"))
         ()
    )
  )
)

(unused-op OP_X0 OPX0_UNUSED_0e 00_0E)
(unused-op OP_X0 OPX0_UNUSED_11 00_11)
(unused-op OP_X0 OPX0_UNUSED_13 00_13)
(unused-op OP_X0 OPX0_UNUSED_14 00_14)
(unused-op OP_X0 OPX0_UNUSED_16 00_16)
(unused-op OP_X0 OPX0_UNUSED_18 00_18)
(unused-op OP_X0 OPX0_UNUSED_19 00_19)
(unused-op OP_X0 OPX0_UNUSED_1a 00_1A)
(unused-op OP_X0 OPX0_UNUSED_1b 00_1B)
(unused-op OP_X0 OPX0_UNUSED_1e 00_1E)

(unused-op2 OP_X2 OPX2_UNUSED_00 02_00)
(unused-op2 OP_X2 OPX2_UNUSED_02 02_02)
(unused-op2 OP_X2 OPX2_UNUSED_04 02_04)
(unused-op2 OP_X2 OPX2_UNUSED_07 02_07)
(unused-op2 OP_X2 OPX2_UNUSED_0a 02_0A)
(unused-op2 OP_X2 OPX2_UNUSED_0b 02_0B)
(unused-op2 OP_X2 OPX2_UNUSED_0c 02_0C)
(unused-op2 OP_X2 OPX2_UNUSED_0d 02_0D)
(unused-op2 OP_X2 OPX2_UNUSED_0e 02_0E)
(unused-op2 OP_X2 OPX2_UNUSED_0f 02_0F)
(unused-op2 OP_X2 OPX2_UNUSED_17 02_17)
(unused-op2 OP_X2 OPX2_UNUSED_19 02_19)
(unused-op2 OP_X2 OPX2_UNUSED_1b 02_1B)
(unused-op2 OP_X2 OPX2_UNUSED_1d 02_1D)

(unused-op OP_UNUSED_01 x-op2 "01")
(unused-op OP_UNUSED_03 x-op2 "03")
(unused-op OP_UNUSED_06 x-op2 "06")
(unused-op OP_UNUSED_07 x-op2 "07")
(unused-op OP_UNUSED_14 x-op2 14)
(unused-op OP_UNUSED_15 x-op2 15)
(unused-op OP_UNUSED_16 x-op2 16)
(unused-op OP_UNUSED_17 x-op2 17)
(unused-op OP_UNUSED_1d x-op2 1D)
(unused-op OP_UNUSED_1f x-op2 1F)
         
