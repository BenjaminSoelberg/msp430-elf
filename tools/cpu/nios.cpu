; Altera NIOS CPU description.  -*- Scheme -*-
; Copyright (C) 2000, 2001 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

(include "simplify.inc")

; define-arch must appear first

(define-arch
  (name nios) ; name of cpu architecture
  (comment "Altera NIOS")
  (default-alignment forced)
  (insn-lsb0? #t)
  (machs nios16 nios32)
  (isas nios)
)

; isa definition
;
(define-isa
  (name nios)
  (base-insn-bitsize 16)
  ; Initial bitnumbers to decode insns by.
  (decode-assist (15 14 13 12 11 10))
  (liw-insns 1)       ; The nios fetches  up to 1 insns at a time.
  (parallel-insns 1)  ; The nios only executes up to 1 insn at a time.
)

; CPU families
;
(define-cpu
  ; cpu names must be distinct from the architecture name and machine names.
  ; The "b" suffix stands for "base" and is the convention.
  ; The "f" suffix stands for "family" and is the convention.
  (name nios16bf)
  (comment "Altera NIOS 16-bit base family")
  (endian little)
  (word-bitsize 16)
  ; Generated files have a "16" suffix.
  (file-transform "16")
)
  
(define-cpu
  ; cpu names must be distinct from the architecture name and machine names.
  ; The "b" suffix stands for "base" and is the convention.
  ; The "f" suffix stands for "family" and is the convention.
  (name nios32bf)
  (comment "Altera NIOS 32-bit base family")
  (endian little)
  (word-bitsize 32)
  ; Generated files have a "32" suffix.
  (file-transform "32")

)

; Machine definitions
;

; 16-bit NIOS machine.
(define-mach
  (name nios16)
  (comment "16-bit NIOS cpu")
  (cpu nios16bf)
)
; 32-bit NIOS machine.
(define-mach
  (name nios32)
  (comment "32-bit NIOS cpu")
  (cpu nios32bf)
)

; Model definitions
;
(define-model
  (name nios16-1) (comment "16-bit NIOS model") (attrs)
  (mach nios16)

  ; `state' is a list of variables for recording model state
  (state
   ; bit mask of h-gr registers loaded from memory by previous insn
   (load-regs UINT)
   ; bit mask of h-gr registers loaded from memory by current insn
   (load-regs-pending UINT)
   )

  (unit u-exec "Execution Unit" ()
        1 1 ; issue done
        () ; state
        () ; inputs
        () ; outputs
        () ; profile action (default)
        )
)

(define-model
  (name nios32-1) (comment "32-bit NIOS model") (attrs)
  (mach nios32)

  ; `state' is a list of variables for recording model state
  (state
   ; bit mask of h-gr registers loaded from memory by previous insn
   (load-regs UINT)
   ; bit mask of h-gr registers loaded from memory by current insn
   (load-regs-pending UINT)
   )

  (unit u-exec "Execution Unit" ()
        1 1 ; issue done
        () ; state
        () ; inputs
        () ; outputs
        () ; profile action (default)
        )
)

 
; Macros to simplify MACH attribute specification.

(define-pmacro (MACH16) (MACH nios16))
(define-pmacro (MACH32) (MACH nios32))



; Instruction fields.
;
; Attributes:
; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
; RESERVED: bits are not used to decode insn, must be all 0

(dnf f-op6        "6-bit opcode"                  () 15  6)
(dnf f-op3        "3-bit opcode"                  () 15  3)
(dnf f-op4        "4-bit opcode"                  () 15  4)
(dnf f-op5        "5-bit opcode"                  () 15  5)
(dnf f-op5-hi     "5-bit hi opcode of pfx'd insn" () 31  5)
(dnf f-op8        "8-bit-opcode"                  () 15  8)
(dnf f-op9        "9-bit-opcode"                  () 15  9)
(dnf f-op11       "11-bit opcode"                 () 15 11)
(dnf f-Ra         "source register a"             ()  4  5)
(dnf f-Rb         "source register b"             ()  9  5)
(dnf f-Rbi5       "source register b or i5"       ()  9  5)
(dnf f-Rz         "source register z"             ()  1  2)
(dnf f-Rp         "base pointer register"         () 11  2)
(dnf f-CTLc       "ctl register"                  ()  4  3)
(dnf f-i2         "2-bit immediate value"         ()  6  2)
(dnf f-i4w        "4-bit word immediate value"    ()  3  4)
(dnf f-x1         "1-bit ignored"                 ()  4  1)
(dnf f-o1         "zero-bit"                      ()  5  1)
(dnf f-o2         "2 zero-bits"                   ()  7  2)
(dnf f-i5         "5-bit immediate value"         ()  9  5)
(dnf f-i6v        "6-bit immediate value"         ()  5  6)
(dnf f-i8         "8-bit immediate value"         () 12  8)
(dnf f-i8v        "8-bit immediate value"         ()  7  8)
(dnf f-i9         "9-bit immediate value"         ()  9  9)
(dnf f-i10        "10-bit immediate value"        ()  9 10)
(dnf f-i11        "11-bit immediate value"        () 10 11)

; for 6 bit relative fields we must make a special check for pc and value both being 0.  This
; is because the field calculation subtracts 4 from the relative offset since it will be added
; when decoded for the ldc instruction.  On the first pass of the assembler, the value and pc
; are unknown (both 0) so the calculation yields -4 which is invalid for the 6-bit UINT field.

(df  f-i6-rel-h   "6 bit pc half-word relative unsigned offset" (PCREL-ADDR) 10 6 UINT
     ((value pc) (cond USI
		       ((eq (or USI value pc) (const 0)) (const 0))
		       (else (sub USI (sra USI (sub USI value pc) (const 1)) (const 2)))))
     ((value pc) (add USI (sll USI value (const 1)) (add USI (and pc (const #x1fffe)) (const 4))))
)

(df  f-i6-rel-w   "6 bit pc word relative unsigned offset" (PCREL-ADDR) 10 6 UINT
     ((value pc) (cond USI
		       ((eq (or USI value pc) (const 0)) (const 0))
		       (else (sub USI (sra USI (sub USI value pc) (const 2)) (const 1)))))
     ((value pc) (add USI (sll USI value (const 2)) (add USI (and pc (const #xfffffffc)) (const 4))))
)

(df  f-i8v-rel-h   "8 bit pc half-word relative unsigned offset" (PCREL-ADDR) 7 8 UINT
     ((value pc) (cond USI
		       ((eq (or USI value pc) (const 0)) (const 0))
		       (else (sub USI (sra USI (sub USI value pc) (const 1)) (const 1)))))
     ((value pc) (add USI (sll USI value (const 1)) (add USI (and pc (const #x1fffe)) (const 2))))
)

(df  f-i8v-rel-w   "8 bit pc word relative unsigned offset" (PCREL-ADDR) 7 8 UINT
     ((value pc) (cond USI
		       ((eq (or USI value pc) (const 0)) (const 0))
		       (else (sub USI (sra USI (sub USI value pc) (const 1)) (const 1)))))
     ((value pc) (and USI (add USI (sll USI value (const 1)) (add USI pc (const 2))) (const #xfffffffc)))
)

(df  f-i11-rel   "11 bit pc half-word relative signed offset" (PCREL-ADDR) 10 11 INT
     ((value pc) (sub SI (sra SI (sub SI value pc) (const 1)) (const 1)))
     ((value pc) (add USI (add SI (sll SI value (const 1)) pc) (const 2)))
)

(df  f-i1        "1-bit immediate value"        ()  6  2 UINT
     ((value pc) (sll UWI value (const 1)))
     ((value pc) (srl UWI value (const 1)))
)

(define-normal-insn-enum insn-op6 "insn op6 enums" () OP_ f-op6
 (
 (ADD  #x0)   (ADDI #x1)    (SUB  #x2)  (SUBI  #x3)
 (CMP  #x4)   (CMPI #x5)    (LSL  #x6)  (LSLI  #x7) 
 (LSR  #x8)   (LSRI #x9)    (ASR  #xa)  (ASRI  #xb)
 (MOV  #xc)   (MOVI #xd)    (AND  #xe)  (ANDN  #xf)
 (OR   #x10)  (XOR  #x11)   (BGEN #x12) (EXT8d #x13)
 (SKP0 #x14)  (SKP1 #x15)   (LD   #x16) (ST    #x17)
 (STS8s #x18) (STS16s #x19) (ADDC #x1a) (EXT16d #x1a)
 (SUBC #x1b)  (MOVHI #x1b)  (USR0 #x1c)
 )
)

(define-normal-insn-enum insn-pfx-hi "insn pfx enum" () OP_ f-op5-hi
 (
 (PFX_HI #x13)
 )
)

; Some opcodes are actually defined by the first 3 bits instead of 6 bits
(define-normal-insn-enum insn-op3 "insn op3 enums" () OP_ f-op3
 (
 (STS 6) (LDS 7)
 )
)

; Some opcodes are actually defined by the first 4 bits instead of 6 bits
(define-normal-insn-enum insn-op4 "insn op4 enums" () OP_ f-op4
 (
 (STP #xa) (LDP #xb)
 )
)

; Some opcodes are actually defined by the first 5 bits instead of 6 bits
(define-normal-insn-enum insn-op5 "insn op5 enums" () OP_ f-op5
 (
 (BR #x10) (BSR #x11) (LDC #x12) (PFX #x13)
 )
)
 
(define-normal-insn-enum insn-op8 "insn op8 enums" () OP_ f-op8
 (
 (SAVE #x78) (TRAP #x79) (JMPC #x7a) (CALLC #x7b)
 )
)

(define-normal-insn-enum insn-op9 "insn op9 enums" () OP_ f-op9
 (
 (EXT8s #x0e8) (EXT16s #x0e9) (ST8s #x0ec) (ST16s #x0ed)
 )
)

(define-normal-insn-enum insn-op11 "insn op11 enums" () OP_ f-op11
 (
 (NOT     #x3e0) (NEG     #x3e1) (ABS     #x3e2) (SEXT8   #x3e3)
 (SEXT16  #x3e4) (RLC     #x3e5) (RRC     #x3e6)
 (SWAP    #x3e8) (USR1    #x3e9) (USR2    #x3ea) (USR3    #x3eb)
 (USR4    #x3ec) (RESTORE #x3ed) (TRET    #x3ee)
 (ST8d    #x3f0) (ST16d   #x3f1) (FILL8   #x3f2) (FILL16  #x3f3)
 (MSTEP   #x3f4) (MUL     #x3f5) (SKPRz   #x3f6) (SKPS    #x3F7)
 (WRCTL   #x3f8) (RDCTL   #x3f9) (SKPRnz  #x3fa)
 (BSRR    #x3fc)                 (JMP     #x3fe) (CALL    #x3ff)
 )
)


; Common Hardware pieces.
; These entries list the elements of the raw hardware.
; They're also used to provide tables and other elements of the assembly
; language.
(define-hardware 
  (name h-pc)
  (comment "program counter")
  (attrs PC PROFILE)
  (type pc)
  (indices)
  (get) ; get
  (set) ; set
)

; CWP is actually part of STATUS register but will be accessed more often
; by itself.  We can assemble STATUS register when needed.
(define-hardware 
  (name h-cwp)
  (comment "current window pointer")
  (attrs PROFILE)
  (type register UQI)
  (indices)
  (get) ; get
  (set (newval) (c-call VOID "@cpu@_h_cwp_set_handler" newval))
)

; Old CWP
(define-hardware 
  (name h-old-cwp)
  (comment "old window pointer")
  (attrs PROFILE)
  (type register UQI)
  (indices)
  (get) ; get
  (set) ; set
)

; IPRI is actually part of STATUS register but will be accessed more often
; by itself.  We can assemble STATUS register when needed.
(define-hardware 
  (name h-ipri)
  (comment "interrupt priority")
  (attrs PROFILE CACHE-ADDR)
  (type register UQI)
  (indices)
  (get) ; get
  (set) ; set
)

; Zero-bit
(define-hardware 
  (name h-zero)
  (comment "enforced zero bit")
  (attrs)
  (type register BI (1))
  (indices)
  (get); get
  (set); set
)

; These bits are actually part of the STATUS register but are accessed more
; often than the entire register, so define them directly. We can assemble
; the STATUS register from its components when necessary.

(dsh h-tebit "trap enable bit" ()           (register BI))
(dsh h-nbit  "negative    bit" ()           (register BI))
(dsh h-zbit  "zero        bit" ()           (register BI))
(dsh h-vbit  "overflow    bit" ()           (register BI))
(dsh h-cbit  "carry       bit" ()           (register BI))
(dsh h-pbit  "prefix      bit" ()           (register BI))
(dsh h-sbit  "skip        bit" ()           (register BI))
(dsh h-wbit  "window chg  bit" ()           (register BI))

(define-hardware 
  (name h-status)
  (comment "status register")
  (attrs PROFILE)
  (type register UHI)
  (indices)
  (get () (c-call UWI "@cpu@_h_status_get_handler")) ; get
  (set (newval) (c-call VOID "@cpu@_h_status_set_handler" newval))  ; set
)

(define-hardware 
  (name h-k)
  (comment "prefix register")
  (attrs PROFILE CACHE-ADDR)
  (type register HI)
  (indices)
  (get)
  (set)
)

; Control registers
;
(define-keyword
  (name ctl-names)
  (print-name h-ctl)
  (prefix "")
  (values
   (%ctl0   0) (%ctl1   1) (%ctl2   2) (%ctl3    3) (%ctl4    4) (%ctl5    5)
   (%status 0)(%istatus 1) (%wvalid 2) (%cd_bank 3) (%st_bank 4) (%ld_bank 5)
  )
)


; General registers
;
(define-keyword
  (name gr-names)
  (print-name h-gr)
  (prefix "")
  (values
   (%sp  14)(%fp  30)
   (%g0   0)(%g1   1)(%g2   2)(%g3   3)(%g4   4)(%g5   5)(%g6   6)(%g7   7)
   (%r0   0)(%r1   1)(%r2   2)(%r3   3)(%r4   4)(%r5   5)(%r6   6)(%r7   7)
   (%o0   8)(%o1   9)(%o2  10)(%o3  11)(%o4  12)(%o5  13)(%o6  14)(%o7  15)
   (%r8   8)(%r9   9)(%r10 10)(%r11 11)(%r12 12)(%r13 13)(%r14 14)(%r15 15)
   (%l0  16)(%l1  17)(%l2  18)(%l3  19)(%l4  20)(%l5  21)(%l6  22)(%l7  23)
   (%r16 16)(%r17 17)(%r18 18)(%r19 19)(%r20 20)(%r21 21)(%r22 22)(%r23 23)
   (%i0  24)(%i1  25)(%i2  26)(%i3  27)(%i4  28)(%i5  29)(%i6  30)(%i7  31)
   (%r24 24)(%r25 25)(%r26 26)(%r27 27)(%r28 28)(%r29 29)(%r30 30)(%r31 31)
  )
)

(define-keyword
  (name gr0-name)
  (print-name h-gr0)
  (prefix "")
  (values
   (%r0   0)
  )
)

(define-keyword
  (name bp-names)
  (print-name h-bp)
  (prefix "")
  (values
   (%l0  0) (%l1  1) (%l2  2) (%l3  3)
   (%r16 0) (%r17 1) (%r18 2) (%r19 3)
  )
)

; Operands

(define-attr
  (for operand)
  (type boolean)
  (name HASH-PREFIX)
  (comment "immediates have an optional '#' prefix")
)

(dnop K         "K register"                      (SEM-ONLY)    h-k     f-nil)

(dnop CTLc      "control register index"          (HASH-PREFIX) h-uint  f-CTLc)
(dnop xRa       "Ra ignored"                      ()            h-uint  f-Ra)
(dnop x1        "1 bit ignored"                   ()            h-uint  f-x1)
(dnop o1        "zero-bit"                        ()            h-zero  f-o1)
(dnop o2        "2 zero bits"                     ()            h-zero  f-o2)
(dnop i1        "1 bit unsigned immediate"        (HASH-PREFIX) h-uint  f-i1)
(dnop i2        "2 bit unsigned immediate"        (HASH-PREFIX) h-uint  f-i2)
(dnop si5       "5 bit signed immediate"          (HASH-PREFIX) h-sint  f-i5)
(dnop i8        "8 bit unsigned immediate"        (HASH-PREFIX) h-uint  f-i8)
(dnop i8v       "8 bit unsigned immediate v"      (HASH-PREFIX) h-uint  f-i8v)
(dnop i6v       "6 bit unsigned immediate v"      (HASH-PREFIX) h-uint  f-i6v)
(dnop si11      "11 bit signed immediate"         (HASH-PREFIX) h-sint  f-i11)
(dnop rel11     "11 bit relative address"         ()            h-iaddr f-i11-rel)
(dnop bsrr_fill "dummy fill relative address"     (RELAX)       h-iaddr f-nil)

(dnop nbit  "negative    bit"       (SEM-ONLY) h-nbit  f-nil)
(dnop vbit  "overflow    bit"       (SEM-ONLY) h-vbit  f-nil)
(dnop zbit  "zero        bit"       (SEM-ONLY) h-zbit  f-nil)
(dnop cbit  "carry       bit"       (SEM-ONLY) h-cbit  f-nil)
(dnop tebit "trap-enable bit"       (SEM-ONLY) h-tebit f-nil)
(dnop pbit  "prefix      bit"       (SEM-ONLY) h-pbit  f-nil)
(dnop sbit  "skip        bit"       (SEM-ONLY) h-sbit  f-nil)
(dnop wbit  "window chg  bit"       (SEM-ONLY) h-wbit  f-nil)

(define-operand
  (name i4w)
  (attrs HASH-PREFIX)
  (comment "4 bit condition code index")
  (type h-uint)
  (index f-i4w)
  (handlers (parse "i4w") (print "i4w"))
)

(define-operand
  (name i4wn)
  (attrs HASH-PREFIX)
  (comment "4 bit condition code index reversed")
  (type h-uint)
  (index f-i4w)
  (handlers (parse "i4wn") (print "i4w"))
)
 
(define-operand
  (name i5)
  (attrs HASH-PREFIX)
  (comment "5 bit unsigned immediate")
  (type h-uint)
  (index f-i5)
  (handlers (parse "i5"))
)

(define-operand
  (name save_i8v)
  (attrs HASH-PREFIX)
  (comment "8 bit unsigned immediate for save insn")
  (type h-uint)
  (index f-i8v)
  (handlers (parse "save_i8v"))
)

(define-operand
  (name i11)
  (attrs HASH-PREFIX)
  (comment "11 bit unsigned immediate")
  (type h-uint)
  (index f-i11)
  (handlers (parse "i11") (print "i11"))
)

(define-operand
  (name i10)
  (attrs HASH-PREFIX)
  (comment "10 bit unsigned immediate")
  (type h-uint)
  (index f-i10)
  (handlers (parse "i10"))
)

(define-operand
  (name i9)
  (attrs HASH-PREFIX)
  (comment "9 bit unsigned immediate")
  (type h-uint)
  (index f-i9)
  (handlers (parse "i9"))
)

(define-operand
  (name i16)
  (attrs SEM-ONLY HASH-PREFIX)
  (comment "16 bit unsigned immediate")
  (type h-uint)
  (index f-nil)
  (handlers (parse "i16") (print "i16"))
)

(define-operand
  (name i32)
  (attrs SEM-ONLY HASH-PREFIX)
  (comment "32 bit unsigned immediate")
  (type h-uint)
  (index f-nil)
  (handlers (parse "i32") (print "i32"))
)

(define-operand
  (name Rbi5)
  (attrs)
  (comment "5 bit register or unsigned immediate")
  (type h-uint)
  (index f-Rbi5)
  (handlers (parse "Rbi5") (print "Rbi5"))
)

; Common macros
;

(define-attr
  (for insn)
  (type boolean)
  (name PREFIX)
  (comment "prefix insn")
)

(define-attr
  (for insn)
  (type boolean)
  (name PREFIXED-INSN)
  (comment "insn that binds with PFX")
)

(define-attr
  (for insn)
  (type boolean)
  (name SKIP-INSN)
  (comment "skip-type insn")
)

(define-attr
  (for insn)
  (type boolean)
  (name DUAL-MODE)
  (comment "insn that changes its second operand based on PFX instruction")
)


(define-pmacro (set-z-and-n x rtype)
  (sequence ()
	    (set zbit (eq rtype x (const 0)))
	    (set nbit (lt rtype x (const 0))))
)

(define-pmacro (arithmetic-op-com name reg_size rtype attrs insn comment opc op arg1 arg2)
  (dni (.sym name reg_size)
       (.str insn " " comment)
       (attrs)
       (.str insn " $" arg1 ",$" arg2)
       (+ opc arg1 arg2)
       (sequence ()
		 (set pbit (const 0))
		 (set vbit ((.sym op -oflag) rtype arg1 arg2 (const 0)))
		 (set cbit ((.sym op -cflag) rtype arg1 arg2 (const 0)))
		 (set arg1 (op rtype arg1 arg2))
		 (set-z-and-n arg1 rtype))
       ()
       )
  )

(define-pmacro (arithmetic-imm-op-com name reg_size rtype attrs insn comment opc op arg1 arg2)
  (begin
    (dni (.sym name reg_size)
	 (.str insn " " comment)
	 (attrs PREFIXED-INSN)
	 (.str insn " $" arg1 ",$" i5)
	 (+ opc arg1 i5)
	 (sequence ((rtype K5))
		   (if (ne pbit (const 0))
		       (set K5 (zext rtype (or HI K i5)))
		       (set K5 i5))
		   (set pbit (const 0))
		   (set vbit ((.sym op -oflag) rtype arg1 K5 (const 0)))
		   (set cbit ((.sym op -cflag) rtype arg1 K5 (const 0)))
		   (set arg1 (op rtype arg1 K5))
		   (set-z-and-n arg1 rtype))
	 ()
	 
    )
  )
)

(define-pmacro (logical-dual-op-com name reg_size rtype attrs insn comment opc op arg1 regb-type)
  (begin
    (dni (.sym name reg_size)
	 (.str insn " " comment)
	 (attrs PREFIXED-INSN DUAL-MODE)
	 (.str insn " $" arg1 ",$Rbi5")
	 (+ opc arg1 Rbi5)
	 (sequence ((rtype tmp))
		   (if (ne pbit (const 0))
		       (set tmp (zext rtype (or HI K Rbi5)))
		       (set tmp (reg regb-type Rbi5)))
		   (set pbit (const 0))
		   (set arg1 (op rtype arg1 tmp))
		   (set-z-and-n arg1 rtype))
	 ()
	 
    )
  )
)

(define-pmacro (andn-com reg_size rtype attrs arg1 regb-type)
  (begin
    (dni (.sym andn reg_size)
	 (.str "andn reg/{reg | imm}")
	 (attrs PREFIXED-INSN DUAL-MODE)
	 (.str "andn $" arg1 ",$Rbi5")
	 (+ OP_ANDN arg1 Rbi5)
	 (sequence ((rtype tmp))
		   (if (ne pbit (const 0))
		       (set tmp (inv rtype (zext rtype (or HI K Rbi5))))
		       (set tmp (inv rtype (reg regb-type Rbi5))))
		   (set pbit (const 0))
		   (set arg1 (and rtype arg1 tmp))
		   (set-z-and-n arg1 rtype))
	 ()
	 
    )
  )
)

(define-pmacro (monadic-op-com name reg_size rtype attrs insn comment opc op arg1)
  (dni (.sym name reg_size)
       (.str insn " " comment)
       (attrs)
       (.str insn " $" arg1)
       (+ opc arg1)
       (sequence ()
		 (set pbit (const 0))
		 (set arg1 (op rtype arg1)))
       ()
       )
  )

(define-pmacro (shift-op-com name reg_size rtype attrs insn comment opc op arg1 arg2)
  (dni (.sym name reg_size)
       (.str insn " " comment)
       (attrs)
       (.str insn " $" arg1 ",$" arg2)
       (+ opc arg1 arg2)
       (sequence ((SI mask))
		 (set pbit (const 0))
		 (set mask (sub SI reg_size (const 1)))
		 (set arg1 (op rtype arg1 (and SI (zext SI arg2) mask))))
       ()

  )
)

(define-pmacro (shift-imm-op-com name reg_size rtype attrs insn comment opc op arg1)
  (dni (.sym name reg_size)
       (.str insn " " comment)
       (attrs)
       (.str insn " $" arg1 ",$i5")
       (+ opc arg1 i5)
       (sequence ((SI mask))
		 (set pbit (const 0))
		 (set mask (sub SI reg_size (const 1)))
		 (set arg1 (op rtype arg1 (and SI (zext SI i5) mask))))
       ()

  )
)

(define-pmacro (mov-com reg_size rtype attrs arg1 arg2)
  (dni (.sym mov reg_size)
       (.str "mov reg/reg")
       (attrs)
       (.str "mov $" arg1 ",$" arg2)
       (+ OP_MOV arg1 arg2)
       (sequence ()
		 (set pbit (const 0))
		 (set arg1 arg2))
       ()

  )
)

(define-pmacro (movi-com reg_size rtype attrs arg1)
  (dni (.sym movi reg_size)
       (.str "movi reg/imm")
       (attrs PREFIXED-INSN)
       (.str "movi $" arg1 ",$i5")
       (+ OP_MOVI arg1 i5)
       (sequence ((rtype K5))
		 (if (ne pbit (const 0))
		     (set K5 (zext rtype (or HI K i5)))
		     (set K5 i5))
		 (set pbit (const 0))
		 (set arg1 K5))
       ()

  )
)

(define-pmacro (bgen-com reg_size rtype attrs arg1)
  (dni (.sym bgen reg_size)
       (.str "bgen reg/imm")
       (attrs)
       (.str "bgen $" arg1 ",$i5")
       (+ OP_BGEN arg1 i5)
       (sequence ((SI tmp) (SI mask))
		 (set pbit (const 0))
		 (set mask (sub SI reg_size (const 1)))
		 (set tmp (zext SI (and SI i5 mask)))
		 (set arg1 (sll rtype (const 1) tmp)))
       ()

  )
)

(define-pmacro (cmp-com reg_size rtype attrs arg1 arg2)
  (dni (.sym cmp reg_size)
       (.str "cmp reg/reg")
       (attrs)
       (.str "cmp $" arg1 ",$" arg2)
       (+ OP_CMP arg1 arg2)
       (sequence ((rtype tmp))
		 (set pbit (const 0))
		 (set vbit (sub-oflag rtype arg1 arg2 (const 0)))
		 (set cbit (sub-cflag rtype arg1 arg2 (const 0)))
		 (set tmp (sub rtype arg1 arg2))
		 (set-z-and-n tmp rtype))
       ()

  )
)

(define-pmacro (cmpi-com reg_size rtype attrs arg1)
  (dni (.sym cmpi reg_size)
       (.str "cmpi reg/imm")
       (attrs PREFIXED-INSN)
       (.str "cmpi $" arg1 ",$i5")
       (+ OP_CMPI arg1 i5)
       (sequence ((rtype tmp) (rtype K5))
		 (if (ne pbit (const 0))
		     (set K5 (zext rtype (or HI K i5)))
		     (set K5 i5))
		 (set pbit (const 0))
		 (set vbit (sub-oflag rtype arg1 K5 (const 0)))
		 (set cbit (sub-cflag rtype arg1 K5 (const 0)))
		 (set tmp (sub rtype arg1 K5))
		 (set-z-and-n tmp rtype))
       ()

  )
)

(define-pmacro (ldc-com reg_size rtype attrs arg1 rel6)
  (dni (.sym ldc reg_size)
       (.str "ldc reg/imm")
       (attrs)
       (.str "ldc $" arg1 ",[$" rel6 "]")
       (+ OP_LDC arg1 rel6)
       (sequence ()
		 (set pbit (const 0))
		 (set arg1 (mem rtype rel6)))
       ()

  )
)

(define-pmacro (ext8d-com reg_size rtype attrs arg1 arg2)
  (dni (.sym ext8d reg_size)
       (.str "ext8d reg/reg")
       (attrs)
       (.str "ext8d $" arg1 ",$" arg2)
       (+ OP_EXT8d arg1 arg2)
       (sequence ((SI tmp) (SI mask))
		 (set pbit (const 0))
		 (set mask (sub SI (srl SI reg_size (const 3)) (const 1)))
		 (set tmp (and (zext SI arg2) mask))
		 (set arg1 (srl rtype arg1 (sll tmp (const 3))))
		 (set arg1 (and rtype arg1 (const #xff))))
       ()
  )
)

(define-pmacro (sext8-com reg_size rtype attrs arg1)
  (dni (.sym sext8 reg_size)
       (.str "sext8 reg")
       (attrs)
       (.str "sext8 $" arg1)
       (+ OP_SEXT8 arg1)
       (sequence ((QI tmp))
		 (set pbit (const 0))
		 (set tmp (trunc QI arg1))
		 (set arg1 (ext rtype tmp)))
       ()
  )
)


(define-pmacro (fill8-com reg_size rtype attrs arg1 arg2)
  (dni (.sym fill8 reg_size)
       (.str "fill8 r0/reg")
       (attrs)
       (.str "fill8 $" arg1 ",$" arg2)
       (+ OP_FILL8 arg2)
       (sequence ((rtype tmp) (rtype tmp2))
		 (set pbit (const 0))
		 (set tmp (and rtype arg2 (const #xff)))
		 (set tmp2 (sll rtype tmp (const 8)))
		 (set tmp (or rtype tmp tmp2))
		 (if (eq reg_size (const 32))
		     (sequence ()
			       (set tmp2 (sll tmp (const 16)))
			       (set tmp (or rtype tmp tmp2)))
		     )
		 (set arg1 tmp))
       ()
  )
)

(define-pmacro (lds-com reg_size rtype attrs arg1 sp)
  (dni (.sym lds reg_size)
       (.str "lds reg,[sp, imm]")
       (attrs)
       (.str "lds $" arg1 ",[$" sp ",$i8]")
       (+ OP_LDS arg1 i8)
       (sequence ((rtype tmp) (SI word_bits) (rtype sp_word))
		 (set pbit (const 0))
		 (set word_bits (srl reg_size (const 4)))
		 (set tmp (sll rtype i8 word_bits))
		 (set sp_word (sll rtype (srl rtype sp word_bits) word_bits))
		 (set arg1 (mem rtype (zext SI (add rtype sp_word tmp)))))
       ()
  )
)

(define-pmacro (sts-com reg_size rtype attrs arg1 sp)
  (dni (.sym sts reg_size)
       (.str "sts [sp, imm],reg")
       (attrs)
       (.str "sts [$" sp ",$i8],$" arg1)
       (+ OP_STS i8 arg1)
       (sequence ((rtype tmp) (SI word_bits) (rtype sp_word))
		 (set pbit (const 0))
		 (set word_bits (srl reg_size (const 4)))
		 (set tmp (sll rtype i8 word_bits))
		 (set sp_word (sll rtype (srl rtype sp word_bits) word_bits))
		 (set (mem rtype (zext SI (add rtype sp_word tmp))) arg1))
       ()
  )
)
 


(define-pmacro (ldp-com reg_size rtype attrs arg1 bp)
  (dni (.sym ldp reg_size)
       (.str "ldp reg,[bp, imm]")
       (attrs PREFIXED-INSN)
       (.str "ldp $" arg1 ",[$" bp ",$i5]")
       (+ OP_LDP arg1 bp i5)
       (sequence ((rtype tmp) (rtype K5) (SI word_bits) (rtype bp_word))
		 (if (ne pbit (const 0))
		     (set K5 (ext rtype (or HI K i5)))
		     (set K5 i5))
		 (set pbit (const 0))
		 (set word_bits (srl reg_size (const 4)))
		 (set tmp (sll rtype K5 word_bits))
		 (set bp_word (sll rtype (srl rtype bp word_bits) word_bits))
		 (set arg1 (mem rtype (zext SI (add rtype bp_word tmp)))))
       ()
  )
)

(define-pmacro (stp-com reg_size rtype attrs arg1 bp)
  (dni (.sym stp reg_size)
       (.str "stp [bp, imm],reg")
       (attrs PREFIXED-INSN)
       (.str "stp [$" bp ",$i5],$" arg1)
       (+ OP_STP bp i5 arg1)
       (sequence ((rtype tmp) (rtype K5) (SI word_bits) (rtype bp_word))
		 (if (ne pbit (const 0))
		     (set K5 (ext rtype (or HI K i5)))
		     (set K5 i5))
		 (set pbit (const 0))
		 (set word_bits (srl reg_size (const 4)))
		 (set tmp (sll rtype K5 word_bits))
		 (set bp_word (sll rtype (srl rtype bp word_bits) word_bits))
		 (set (mem rtype (zext SI (add rtype bp_word tmp))) arg1))
       ()
  )
)

(define-pmacro (ld-com reg_size rtype attrs arg1 arg2)
  (dni (.sym ld reg_size)
       (.str "ld reg,[reg]")
       (attrs PREFIXED-INSN)
       (.str "ld $" arg1 ",[$" arg2 "]")
       (+ OP_LD arg1 arg2)
       (sequence ((rtype tmp) (rtype Ktmp))
		 (if (ne pbit (const 0))
		     (set Ktmp (sra (ext rtype K) (const 5)))
		     (set Ktmp (const 0)))
		 (set pbit (const 0))
		 (set tmp (sll rtype Ktmp (srl reg_size (const 4))))
		 (set arg1 (mem rtype (zext SI (add rtype arg2 tmp)))))
       ()
  )
)

(define-pmacro (st-com reg_size rtype attrs arg1 arg2)
  (dni (.sym st reg_size)
       (.str "st [reg],reg")
       (attrs PREFIXED-INSN)
       (.str "st [$" arg2 "],$" arg1)
       (+ OP_ST arg2 arg1)
       (sequence ((rtype tmp) (rtype Ktmp))
		 (if (ne pbit (const 0))
		     (set Ktmp (sra (ext rtype K) (const 5)))
		     (set Ktmp (const 0)))
		 (set pbit (const 0))
		 (set tmp (sll rtype Ktmp (srl reg_size (const 4))))
		 (set (mem rtype (zext SI (add rtype arg2 tmp))) arg1))
       ()
  )
)

(define-pmacro (rdctl-com reg_size rtype attrs arg ctl_reg)
  (dni (.sym rdctl reg_size)
       (.str "rdctl reg")
       (attrs)
       (.str "rdctl $" arg)
       (+ OP_RDCTL arg)
       (sequence ((SI tmp))
		 (if (eq pbit (const 0))
		     (set K (const 0)))
		 (set pbit (const 0))
		 (set tmp (zext SI (srl K (const 5))))
		 (set arg (zext rtype (reg HI ctl_reg tmp))))
       ()
  )
)


(define-pmacro (rrc-com reg_size rtype attrs arg1)
  (dni (.sym rrc reg_size)
       (.str "rrc reg")
       (attrs)
       (.str "rrc $" arg1)
       (+ OP_RRC arg1)
       (sequence ((rtype tmp) (rtype tmp2))
		 (set pbit (const 0))
		 (set tmp (sll rtype (zext rtype cbit) (sub reg_size (const 1))))
		 (set cbit (trunc BI (and rtype arg1 (const 1))))
		 (set arg1 (or rtype tmp (srl rtype arg1 (const 1)))))
       ()
  )
)

(define-pmacro (rlc-com reg_size rtype attrs arg1)
  (dni (.sym rlc reg_size)
       (.str "rlc reg")
       (attrs)
       (.str "rlc $" arg1)
       (+ OP_RLC arg1)
       (sequence ((rtype tmp) (rtype tmp2))
		 (set pbit (const 0))
		 (set tmp (zext rtype cbit))
		 (set cbit (trunc BI (srl rtype arg1 (sub reg_size (const 1)))))
		 (set arg1 (or rtype tmp (sll rtype arg1 (const 1)))))
       ()
  )
)

(define-pmacro (trap-com reg_size rtype attrs)
  (dni (.sym trap reg_size)
       (.str "trap imm")
       (attrs UNCOND-CTI)
       (.str "trap $i6v")
       (+ OP_TRAP o2 i6v)
       (sequence ()
		 (set pbit (const 0))
		 (set pc (c-call IAI "@cpu@_sw_trap" pc i6v)))
       ()
  )
)

(define-pmacro (tret-com reg_size rtype attrs Ra)
  (dni (.sym tret reg_size)
       (.str "tret reg")
       (attrs UNCOND-CTI)
       (.str "tret $" Ra)
       (+ OP_TRET Ra)
       (sequence ()
		 (set pbit (const 0))
		 (set pc (c-call IAI "@cpu@_do_tret" pc Ra)))
       ()
  )
)

(define-pmacro (save-com reg_size rtype attrs sp)
  (dni (.sym save reg_size)
       (.str "save sp/imm")
       (attrs)
       (.str "save $" sp ",$save_i8v")
       (+ OP_SAVE save_i8v)
       (sequence ()
		 (set pbit (const 0))
		 (c-call VOID "@cpu@_do_save" pc save_i8v))
       ()
  )
)

(define-pmacro (restore-com reg_size rtype attrs Ra)
  (dni (.sym restore reg_size)
       (.str "restore")
       (attrs)
       (.str "restore")
       (+ OP_RESTORE Ra)
       (sequence ()
		 (set pbit (const 0))
		 (c-call VOID "@cpu@_do_restore" pc))
       ()
  )
)

(define-pmacro (bsr-com reg_size rtype attrs link_reg)
  (dni (.sym bsr reg_size)
       (.str "bsr rel")
       (attrs UNCOND-CTI DELAY-SLOT)
       (.str "bsr $rel11")
       (+ OP_BSR rel11)
       (sequence ()
		 (set pbit (const 0))
		 (set link_reg (trunc rtype (srl (add pc (const 4)) (const 1))))
		 (set pc rel11))
       ()
  )
)

; Following is imaginary insn used by the compiler to allow relaxation
; to decide if better to use call or bsr sequence - it is never
; decoded or disassembled 
(define-pmacro (bsrr-com reg_size rtype attrs link_reg Ra)
  (dni (.sym bsrr reg_size)
       (.str "bsrr reg,rel")
       (attrs UNCOND-CTI DELAY-SLOT NO-DIS RELAXABLE)
       (.str "bsrr $" Ra ",$" bsrr_fill)
       (+ OP_BSRR Ra)
       (sequence ()
		 (set pbit (const 0))
		 (set link_reg (trunc rtype (srl (add pc (const 4)) (const 1))))
		 (set pc rel11))
       ()
  )
)

(define-pmacro (jmp-com reg_size rtype attrs Ra)
  (dni (.sym jmp reg_size)
       (.str "jmp reg")
       (attrs UNCOND-CTI DELAY-SLOT)
       (.str "jmp $" Ra)
       (+ OP_JMP Ra)
       (sequence ()
		 (set pbit (const 0))
		 (set pc (sll (zext SI Ra) (const 1))))
       ()
  )
)

(define-pmacro (call-com reg_size rtype attrs Ra R15)
  (dni (.sym call reg_size)
       (.str "call reg")
       (attrs UNCOND-CTI DELAY-SLOT)
       (.str "call $" Ra)
       (+ OP_CALL Ra)
       (sequence ()
		 (set pbit (const 0))
		 (set R15 (trunc rtype (srl (add pc (const 4)) (const 1))))
		 (set pc (sll (zext SI Ra) (const 1))))
       ()
  )
)

(define-pmacro (jmpc-com reg_size rtype attrs rel8)
  (dni (.sym jmpc reg_size)
       (.str "jmpc [imm]")
       (attrs UNCOND-CTI DELAY-SLOT)
       (.str "jmpc [$" rel8 "]")
       (+ OP_JMPC rel8)
       (sequence ((rtype tmp2))
		 (set pbit (const 0))
		 (set tmp2 (mem rtype rel8))
		 (set pc (sll (zext SI tmp2) (const 1))))
       ()
  )
)

(define-pmacro (callc-com reg_size rtype attrs rel8 R15)
  (dni (.sym callc reg_size)
       (.str "callc [imm]")
       (attrs UNCOND-CTI DELAY-SLOT)
       (.str "callc [$" rel8 "]")
       (+ OP_CALLC rel8)
       (sequence ((rtype tmp2))
		 (set pbit (const 0))
		 (set R15 (trunc rtype (srl (add pc (const 4)) (const 1))))
		 (set tmp2 (mem rtype rel8))
		 (set pc (sll (zext SI tmp2) (const 1))))
       ()
  )
)

(define-pmacro (skpx-com name insn reg_size rtype attrs arg1 opc op)
  (dni (.sym name reg_size)
       (.str insn " reg")
       (attrs COND-CTI SKIP-INSN)
       (.str insn " $" arg1 ",$i5")
       (+ opc arg1 i5)
       (sequence ((SI tmp) (SI tmp2) (SI mask))
		 (set pbit (const 0))
		 (set mask (sub SI reg_size (const 1)))
		 (set tmp (sll (const 1) (and SI i5 mask)))
		 (set tmp2 (and tmp (zext SI arg1)))
		 (if (op tmp2 (const 0))
		     (set sbit (const 1))
		     (set sbit (const 0))))
       ()
  )
)

(define-pmacro (skprx-com name insn reg_size rtype attrs arg1 opc op)
  (dni (.sym name reg_size)
       (.str insn " reg")
       (attrs COND-CTI SKIP-INSN)
       (.str insn " $" arg1)
       (+ opc arg1)
       (sequence ()
		 (set pbit (const 0))
		 (if (op arg1 (const 0))
			 (set sbit (const 1))
			 (set sbit (const 0))))
       ()
  )
)

(define-pmacro (skps-com reg_size rtype attrs)
  (dni (.sym skps reg_size)
       (.str "skps imm4")
       (attrs COND-CTI SKIP-INSN)
       (.str "skps $i4w")
       (+ OP_SKPS x1 i4w)
       (sequence ((USI tmp))
		 (set pbit (const 0))
		 (set sbit (c-call USI "@cpu@_check_cc_mask" i4w)))
       ()
  )
)

(define-pmacro (nop-com reg_size attrs Ra_type Rb_type)
  (dnmi (.sym nop reg_size) 
	"nop"
	(attrs)
	"nop"
	(emit (.sym mov reg_size) (Ra_type 0) (Rb_type 0))
  )
)

(define-pmacro (counter-com reg_size name attrs arg1 real_op)
  (dnmi (.sym name reg_size) 
	(.str name " reg")
	(attrs)
	(.str name " $" arg1)
	(emit (.sym real_op reg_size) arg1 (i5 1))
  )
)

(define-pmacro (clr-com reg_size attrs arg1)
  (dnmi (.sym clr reg_size) 
	(.str "clr reg")
	(attrs NO-DIS)
	(.str "clr $" arg1)
	(emit (.sym movi reg_size) arg1 (i5 0))
  )
)

(define-pmacro (ret-com reg_size attrs reg_type)
  (dnmi (.sym ret reg_size) 
	(.str "ret")
	(attrs)
	(.str "ret")
	(emit (.sym jmp reg_size) (reg_type 31))
  )
)

(define-pmacro (lret-com reg_size attrs reg_type)
  (dnmi (.sym lret reg_size) 
	(.str "lret")
	(attrs)
	(.str "lret")
	(emit (.sym jmp reg_size) (reg_type 15))
  )
)

(define-pmacro (ifx-com reg_size name attrs arg1 real_op)
  (dnmi (.sym name reg_size) 
	(.str name " reg/imm")
	(attrs NO-DIS)
	(.str name " $" arg1 ",$i5")
	(emit (.sym real_op reg_size) arg1 i5)
  )
)

(define-pmacro (ifrx-com reg_size name attrs arg1 real_op)
  (dnmi (.sym name reg_size) 
	(.str name " reg")
	(attrs NO-DIS)
	(.str name " $" arg1)
	(emit (.sym real_op reg_size) arg1)
  )
)

(define-pmacro (ifs-com reg_size attrs)
  (dnmi (.sym ifs reg_size) 
	(.str "ifs imm4")
	(attrs NO-DIS)
	(.str "ifs $i4wn")
	(emit (.sym skps reg_size) (f-x1 0) (i4w i4wn))
  )
)

; The rest is broken out into various files.

(if (keep-mach? (nios16))
(include "nios16.cpu"))

(if (keep-mach? (nios32))
(include "nios32.cpu"))

(dni pfx "pfx imm" (PREFIX) "pfx $i11" (+ OP_PFX i11) 
     (sequence ()
	       (set pbit (const 1))
	       (set K (sll i11 5)))
     ()
)

(dni br "br rel" (DELAY-SLOT UNCOND-CTI) "br $rel11" (+ OP_BR rel11)
     (sequence ()
	       (set pbit (const 0))
	       (set pc rel11))
     ()
)






