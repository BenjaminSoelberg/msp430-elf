; Samsung CalmRISC32 CPU description.  -*- Scheme -*-
; Copyright (C) 2000 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

(include "simplify.inc")

; define-arch must appear first
(define-arch
  (name calmrisc32) ; name of cpu family
  (comment "Samsung CalmRISC32")
  (default-alignment forced)
  ; should be #t, but the long insns make this impossible.
  (insn-lsb0? #f)
  (machs calmrisc32)
  (isas calmrisc32)
)

; Instruction set parameters.

(define-isa
  (name calmrisc32)
  (comment "Samsung CalmRISC32 ISA")
  (default-insn-word-bitsize 16)
  (default-insn-bitsize 16)
  (base-insn-bitsize 16)
  (liw-insns 1)
  (parallel-insns 2)
)

; Cpu family definitions.

(define-cpu
  ; cpu names must be distinct from the architecture name and machine names.
  (name calmrisc32bf)
  (comment "Samsung CalmRISC32")
  (endian either)
  (word-bitsize 32)
)

(define-mach
  (name calmrisc32)
  (comment "Samsung CalmRISC32")
  (cpu calmrisc32bf)
  (bfd-name "calmrisc32")
)

; Model

(define-model
  (name calmrisc32-150) (comment "CalmRISC32 150mhz") (attrs)
  (mach calmrisc32)
  (pipeline all "" () ((fetch) (decode) (execute) (writeback)))
  (unit u-exec "Execution Unit" ()
        1 1 ; issue done
        () ; state
        () ; inputs
        () ; outputs
        () ; profile action (default)
        )
)


; Attributes

(define-attr
  (type boolean)
  (name FOUR-BYTE)
  (comment "4 byte pc-displacement")
)


; Instruction fields.

(dnf f-rd-8-11        "rd [8:11]"             () 4 4)
(dnf f-rd-8-10        "rd [8:10]"             () 5 3)
(dnf f-rd-0-2         "rd [0:2]"              () 13 3)
(dnf f-rd-0-3         "rd [0:3]"              () 12 4)
(dnf f-rd-4-6         "rd [4:6]"              () 9 3)
(dnf f-rd-4-7         "rd [4:7]"              () 8 4)
(dnf f-imm-2          "imm 2"                 () 14 2)
(dnf f-imm-3          "imm 3"                 () 9 3)
(dnf f-ldrsbs3        "ld rsbs imm:3"         () 13 3)
(dnf f-imm-4          "imm 4"                 () 12 4)
(dnf f-imm-5          "imm 5"                 () 11 5)
(dnf f-imm-7          "imm 7"                 () 9 7)
(dnf f-imm-8          "imm 8"                 () 8 8)
(dnf f-imm-13         "imm 13"                () 3 13)
(dnf f-imm-16         "imm 16"                () 16 16)
(dnf f-imm-32         "imm 32"                () 16 32)
(dnf f-rs-0-2         "rs [0:2]"              () 13 3)
(dnf f-rs-0-3         "rs [0:3]"              () 12 4)
(dnf f-rs-4-6         "rs [4:6]"              () 9 3)
(dnf f-rs-4-7         "rs [4:7]"              () 8 4)
(dnf f-rs-8-10        "rs [8:10]"             () 5 3)
(dnf f-divi-rs1       "divi rs1"              () 13 3)
(dnf f-divi-rs2       "divi rs2"              () 9 3)
(dnf f-rs1            "rs1"                   () 5 3)
(dnf f-rs2            "rs2"                   () 13 3)
(dnf f-bs-3           "bs:3"                  () 13 3)
(dnf f-bs-5           "bs:5"                  () 11 5)
(dnf f-H-4            "h:4"                   () 11 1)
(dnf f-H-8            "h:8"                   () 7 1)
(dnf f-ec             "ec"                    () 6 2)
(dnf f-crs-4-8        "crs [4:8]"             () 7 5)
(dnf f-crs-4-7        "crs [4:7]"             () 8 4)
(dnf f-crd-4-8        "crd [4:8]"             () 7 5)
(dnf f-crd-4-7        "crd [4:7]"             () 8 4)
(dnf f-rb-8-9         "rb [8:9]"              () 6 2)
(dnf f-rb-0-1         "rb [0:1]"              () 14 2)
(dnf f-ro             "ro"                    () 14 2)
(dnf f-disp-4         "disp:4"                () 12 4)
(dnf f-disp-8         "disp:8"                () 8 8)
(dnf f-P              "P"                     () 6 1)
(dnf f-D              "D"                     () 7 1)
(dnf f-spr            "spr"                   () 12 4)
(dnf f-s-5            "s-5"                   () 10 1)
(dnf f-s-8            "s-8"                   () 7 1)
(dnf f-s-11           "s-11"                  () 4 1)
(dnf f-sd             "sd"                    () 4 1)
(dnf f-ss             "ss"                    () 12 1)
(dnf f-qq             "qq"                    () 12 2)
(dnf f-swi_no         "swi_no"                () 12 4)
(dnf f-op1            "opcode [12:15]"        () 0 4)
(dnf f-op2            "opcode [8:11]"         () 4 4)
(dnf f-op3            "opcode [4:7]"          () 8 4)
(dnf f-op4            "opcode [0:3]"          () 12 4)
(dnf f-b13-15         "bits [13:15]"          () 0 3)
(dnf f-b14-15         "bits [14:15]"          () 0 2)
(dnf f-b9-11          "bits [9:11]"           () 4 3)
(dnf f-b10-11         "bits [10:11]"          () 4 2)
(dnf f-bit-11         "bits [11]"             () 4 1)
(dnf f-b6-7           "bits [6:7]"            () 8 2)
(dnf f-b5-7           "bits [5:7]"            () 8 3)
(dnf f-bit-7          "bits [7]"              () 8 1)
(dnf f-bit-5          "bits [5]"              () 10 1)
(dnf f-bit-4          "bits [4]"              () 11 1)
(dnf f-b2-3           "bits [2:3]"            () 12 2)
(dnf f-bit-3          "bits [3]"              () 12 1)
(dnf f-b0-1           "bits [0:1]"            () 14 2)
(dnf f-disp-6-12-13   "disp:6 [12:13]"        () 2 2)
(dnf f-disp-6-0-3     "disp:6 [0:3]"          () 12 4)

(df f-offset-8 "offset:8" (PCREL-ADDR) 8 8 INT
  ((value pc) (srl SI value 1))
  ((value pc) (sll SI value 1))
)
(df f-offset-9 "offset:9" (PCREL-ADDR) 7 9 INT
  ((value pc) (srl SI value 1))
  ((value pc) (sll SI value 1))
)
(df f-offset-10 "offset:10" (PCREL-ADDR) 6 10 INT
  ((value pc) (srl SI value 1))
  ((value pc) (sll SI value 1))
)
(df f-offset-11 "offset:11" (PCREL-ADDR) 5 11 INT
  ((value pc) (srl SI value 1))
  ((value pc) (sll SI value 1))
)
; XXX this causes the generated decoder to be wrong for both opcodes
; and sid.  we use a multi-ifield to work around this.
;(df f-offset-23 "offset:23" (PCREL-ADDR FOUR-BYTE) 9 23 INT
;  ((value pc) (srl SI value 1))
;  ((value pc) (sll SI value 1))
;)
(dnf f-offset-23-16-24 "offset:23 [16:24]"    () 9 7)
(dnf f-offset-23-0-15  "offset:23 [0:15]"     () 16 16)
(define-multi-ifield
  (name f-offset-23)
  (comment "6 bit displacement")
  (attrs PCREL-ADDR FOUR-BYTE)
  (mode INT)
  (subfields f-offset-23-0-15 f-offset-23-16-24)
  (insert (sequence ()
            (set (ifield f-offset-23-16-24) (and (srl (ifield f-offset-23) (const 17)) (const #x7f)))
            (set (ifield f-offset-23-0-15)  (and (srl (ifield f-offset-23) (const 1)) (const #xffff)))))
  (extract (sequence ()
             (set (ifield f-offset-23) (or (sll (or (ifield f-offset-23-0-15)
                                                    (sll (ifield f-offset-23-16-24) (const 16))) 1)
                                           (if USI (and (ifield f-offset-23-16-24) (const #x40))
	                                     (const #xff000000)
	                                     (const 0))))))
)

(df f-cld-disp-4 "cld disp:4" () 12 4 UINT
  ((value pc) (srl USI value 2))
  ((value pc) (sll USI value 2))
)
(df f-ldh-disp-4 "ldh disp:4" () 12 4 UINT
  ((value pc) (srl USI value 1))
  ((value pc) (sll USI value 1))
)

(define-multi-ifield
  (name f-imm-17)
  (comment "17 bit signed immediate for ldh")
  (mode INT)
  (subfields f-imm-16 f-s-5)
  (insert (sequence ()
                    (set (ifield f-imm-16)  (and (ifield f-imm-17) (const #xffff)))
                    (set (ifield f-s-5)     (and (srl (ifield f-imm-17) (const 16)) 1))))
  (extract (sequence ()
                     (set (ifield f-imm-17) (or
                       (and (ifield f-imm-16) (const #xffff))
                       (if SI (ifield f-s-5) (const #xffff0000) (const 0))))))
)

(define-multi-ifield
  (name f-disp-6)
  (comment "6 bit displacement")
  (mode INT)
  (subfields f-disp-6-0-3 f-disp-6-12-13)
  (insert (sequence ()
                    (set (ifield f-disp-6-12-13) (and (srl (ifield f-disp-6) (const 6)) (const #x3)))
                    (set (ifield f-disp-6-0-3)   (and (srl (ifield f-disp-6) (const 2)) (const #xf)))
                    ))
  (extract (sequence ()
                     (set (ifield f-disp-6) (sll (or (ifield f-disp-6-0-3)
                                                     (sll (ifield f-disp-6-12-13) (const 4))) 2))
                     ))
)

(define-multi-ifield
  (name f-sssd)
  (comment "source & destination s bits for mul")
  (mode INT)
  (subfields f-sd f-ss)
  (insert (sequence ()
                    (set (ifield f-sd) (and (srl (ifield f-sssd) (const 1)) (const #x1)))
                    (set (ifield f-ss) (and (ifield f-sssd) (const #x1)))
                    ))
  (extract (sequence ()
                     (set (ifield f-sssd) (or (ifield f-ss)
                                                (sll (ifield f-sd) (const 1))))
                     ))
)


; Enums.

(define-pmacro (insn-op which)
  (begin
    (define-normal-insn-enum (.sym "insn-op" which) (.str "insn op" which " format enums") () (.str "OP" which "_") (.sym "f-op" which)
      (("0" #x0) ("1" #x1) ("2" #x2) ("3" #x3)
       ("4" #x4) ("5" #x5) ("6" #x6) ("7" #x7)
       ("8" #x8) ("9" #x9) ("A" #xa) ("B" #xb)
       ("C" #xc) ("D" #xd) ("E" #xe) ("F" #xf))
    )
  )
)

(insn-op 1)
(insn-op 2)
(insn-op 3)
(insn-op 4)


; Hardware pieces.
; These entries list the elements of the raw hardware.
; They're also used to provide tables and other elements of the assembly
; language.

; global registers
(define-pmacro (defhw-reg me what sz c-name)
  (begin
    (define-hardware
      (name (.sym me))
      (comment what)
      (type register sz)
    )
  )
)

(dnh       h-pc                   "program counter" (PC PROFILE) (pc USI) () () ())

(defhw-reg h-ssr_fiq              "saved status register (fiq)"      USI  "ssr_fiq")
(defhw-reg h-spc_fiq              "saved program counter (fiq)"      USI  "spc_fiq")
(defhw-reg h-ssr_irq              "saved status register (irq)"      USI  "ssr_irq")
(defhw-reg h-spc_irq              "saved program counter (irq)"      USI  "spc_irq")
(defhw-reg h-ssr_swi              "saved status register (swi)"      USI  "ssr_swi")
(defhw-reg h-spc_swi              "saved program counter (swi)"      USI  "spc_swi")
(defhw-reg h-ssr_expt             "saved status register (expt)"     USI  "ssr_expt")
(defhw-reg h-spc_expt             "saved program counter (expt)"     USI  "spc_expt")

; vbr - lower 9 bits are always 0
(define-hardware
  (name h-vbr)
  (comment "vector base register")
  (type register USI)
  (get () (and (raw-reg h-vbr) #xfffffe00))
  (set (value) (set (raw-reg h-vbr) (and value #xfffffe00)))
)

; r0-r3
(define-hardware
  (name h-sr)
  (comment "status register")
  (type register USI)
  (get () (or USI tbit
          (or (sll USI vbit 3)
          (or (sll USI z0bit 4)
          (or (sll USI z1bit 5)
          (or (sll USI dsbit 6)
          (or (sll USI qtbit 7)
          (or (sll USI bxbit 12)
          (or (sll USI hxbit 13)
          (or (sll USI sysx 16)
          (or (sll USI iebit 24)
          (or (sll USI febit 25)
          (or (sll USI tebit 26)
          (or (sll USI bsbit 28)
          (or (sll USI rs0bit 29)
          (or (sll USI rs1bit 30)
              (sll USI pmbit 31)))))))))))))))))
  (set (value) (sequence ()
          (set tbit (and value (sll 1 0)))
          (set vbit (and value (sll 1 3)))
          (set z0bit (and value (sll 1 4)))
          (set z1bit (and value (sll 1 5)))
          (set dsbit (and value (sll 1 6)))
          (set qtbit (and value (sll 1 7)))
          (set bxbit (and value (sll 1 12)))
          (set hxbit (and value (sll 1 13)))
          (set sysx (and (srl value 16) (const #xf)))
          (set iebit (and value (sll 1 24)))
          (set febit (and value (sll 1 25)))
          (set tebit (and value (sll 1 26)))
          (set bsbit (and value (sll 1 28)))
          (set rs0bit (and value (sll 1 29)))
          (set rs1bit (and value (sll 1 30)))
          (set pmbit (and value (sll 1 31)))))
)

(define-keyword
  (name reg-high-names)
  (print-name h-a)
  (prefix "")
  (values
    (r8  0) (r9  1) (r10 2) (r11 3)
    (r12 4) (fp 5) (lr  6) (sp  7)
    (r13 5) (r14 6) (r15 7)
  )
)

(define-keyword
  (name reg-names)
  (print-name h-r)
  (prefix "")
  (values
    (r0 0)   (r1 1)   (r2 2)   (r3 3)  
    (r4 4)   (r5 5)   (r6 6)   (r7 7)
    (r8 8)   (r9 9)   (r10 10) (r11 11)
    (r12 12) (fp 13) (lr 14)  (sp 15)
    (r13 13) (r14 14) (r15 15)
  )
)

; B0_R0-B0_R15
(define-hardware
  (name h-b0-r)
  (comment "registers")
  (type register SI(16))
  (indices extern-keyword reg-names)
)

; B1_R0-B1_R15
(define-hardware
  (name h-b1-r)
  (comment "registers")
  (type register SI(16))
  (indices extern-keyword reg-names)
)

; r0-r15
(define-hardware
  (name h-r)
  (comment "registers")
  (type register SI(16))
  (indices extern-keyword reg-names)
  (get (index)
        (if SI (or (not pmbit) (not bsbit))
          (reg h-b0-r index)
          (if SI (lt index 8)
            (if SI (and (not rs0bit) (not rs1bit))
              (reg h-b1-r index)
              (if SI (and (not rs0bit) rs1bit)
                (reg h-b0-r (add index 8))
                (if SI (and rs0bit (not rs1bit))
                  (reg h-b0-r index)
                  (error SI "invalid rs bits"))))
            (reg h-b1-r index))))
  (set (index newval)
        (if (or (not pmbit) (not bsbit))
          (set (reg h-b0-r index) newval)
          (if (lt index 8)
            (if (and (not rs0bit) (not rs1bit))
              (set (reg h-b1-r index) newval)
              (if (and (not rs0bit) rs1bit)
                (set (reg h-b0-r (add index 8)) newval)
                (if (and rs0bit (not rs1bit))
                  (set (reg h-b0-r index) newval)
                  (error "invalid rs bits"))))
            (set (reg h-b1-r index) newval))))
)

; r0-r3
(define-hardware
  (name h-t)
  (comment "memory index registers")
  (type register SI(4))
  (indices extern-keyword reg-names)
  (get (index) (reg h-r index))
  (set (index newval) (set (reg h-r index) newval))
)

; r0-r7
(define-hardware
  (name h-d)
  (comment "data registers")
  (type register SI(8))
  (indices extern-keyword reg-names)
  (get (index) (reg h-r index))
  (set (index newval) (set (reg h-r index) newval))
)

; r8-r11
(define-hardware
  (name h-b)
  (comment "cld addressing registers")
  (type register SI(4))
  (indices extern-keyword reg-high-names)
  (get (index) (reg h-r (add index 8)))
  (set (index newval) (set (reg h-r (add index 8)) newval))
)

; r8-r15
(define-hardware
  (name h-a)
  (comment "addressing registers")
  (type register SI(8))
  (indices extern-keyword reg-high-names)
  (get (index) (reg h-r (add index 8)))
  (set (index newval) (set (reg h-r (add index 8)) newval))
)

(define-keyword
  (name copro-names)
  (print-name h-cr)
  (prefix "")
  (values
    (fr0 0)   (fr1 1)   (fr2 2)   (fr3 3)   (fr4 4)   (fr5 5)   (fr6 6)   (fr7 7)
    (fr8 8)   (fr9 9)   (fr10 10) (fr11 11) (fr12 12) (fr13 13) (fr14 14) (fr15 15)
    (fr16 16) (fr17 17) (fr18 18) (fr19 19) (fr20 20) (fr21 21) (fr22 22) (fr23 23)
    (fr24 24) (fr25 25) (fr26 26) (fr27 27) (fr28 28) (fr29 29) (fr30 30) (fr31 31)
  )
)

; fr0-fr31
(define-hardware
  (name h-cr)
  (comment "copro registers")
  (type register SI(32))
  (indices extern-keyword copro-names)
)

; fr0-fr15
(define-hardware
  (name h-cr-half)
  (comment "copro registers (first half)")
  (type register SI(16))
  (indices extern-keyword copro-names)
  (get (index) (reg h-cr index))
  (set (index newval) (set (reg h-cr index) newval))
)

(define-pmacro (dbr who what)
  (begin
    (define-hardware
      (name who)
      (comment what)
      (type register BI)
      (get () (raw-reg who))
      (set (newval) (set (raw-reg who) (ne newval 0)))
    )
  )
)

(dbr h-tbit   "true bit")
(dbr h-vbit   "overflow bit")
(dbr h-z0bit  "r6 == 0, bnzd bit")
(dbr h-z1bit  "r7 == 0, bnzd bit")
(dbr h-dsbit  "divisors sign bit")
(dbr h-qtbit  "quotient bit")
(dbr h-bxbit  "ldb sign/zero ext bit")
(dbr h-hxbit  "ldh sign/zero ext bit")
(dbr h-iebit  "enable irq bit")
(dbr h-febit  "enable fiq bit")
(dbr h-tebit  "enable trace bit")
(dbr h-bsbit  "bank select bit")
(dbr h-rs0bit "register select bit 0")
(dbr h-rs1bit "register select bit 1")
(dbr h-pmbit  "processor mode bit")

(dsh h-ecbits "external condition bits"  ()        (register QI))
(dsh h-sysx   "system interface  bits"   ()        (register QI))

; fake hardware to help parse

(define-pmacro (name-loop name num) ((.str name num) num))

(define-pmacro (ec-loop num) (name-loop "ec" num))
(define-hardware
  (name h-ec)             
  (comment "external condition") 
  (attrs)                     
  (type immediate (UINT 4)) 
  (values keyword ""
    (.map ec-loop (.iota 4))
  )
)

(define-hardware
  (name h-sssd)             
  (comment "mul ss/sd bits")
  (attrs)                     
  (type immediate (UINT 4)) 
  (values keyword ""
    (("uu" 0) ("us" 1) ("su" 2) ("ss" 3)))
)

(define-pmacro (q-loop num) (name-loop "q" num))
(define-hardware
  (name h-qq)             
  (comment "pop qq register")
  (attrs)                     
  (type immediate (UINT 4)) 
  (values keyword ""
    (.map q-loop (.iota 4))
  )
)

; useful for long lists of ("N" N)
(define-pmacro (num-loop num) ((.str num) num))

(define-hardware
  (name h-imm-3)             
  (comment "rotate imm-3")
  (attrs)                     
  (type immediate (UINT 8)) 
  (values keyword ""
    (.splice (.unsplice (.map num-loop (.iota 7 1))) ("8" 0))
  )
)

(define-hardware
  (name h-bs-5)             
  (comment "clr/set sr bs-5")
  (attrs)                     
  (type immediate (UINT 32)) 
  (values keyword ""
    (.splice ("t" 0) ("v" 3)
             ("z0" 4) ("z1" 5) ("ds" 6) ("qt" 7)
             ("bx" 12) ("hx" 13)
             ("ie" 24) ("fe" 25) ("te" 26)
             ("bs" 28) ("rs0" 29) ("rs1" 30) ("pm" 31)
             (.unsplice (.map num-loop (.iota 32))))
  )
)

(define-hardware
  (name h-H-4)             
  (comment "sign extent H-4")
  (attrs)                     
  (type immediate (UINT 2)) 
  (values keyword ""
    (("b" 0) ("h" 1)))
)

(define-hardware
  (name h-spr)             
  (comment "special-purpose register")
  (attrs)                     
  (type immediate (UINT 16)) 
  (values keyword ""
    (("sr"      0)  ("vbr"      1)
     ("ssr_fiq" 8)  ("ssr_irq"  9)
     ("ssr_swi" 10) ("ssr_expt" 11)
     ("spc_fiq" 12) ("spc_irq"  13)
     ("spc_swi" 14) ("spc_expt" 15)))
)


; Instruction Operands.
; These entries provide a layer between the assembler and the raw hardware
; description, and are used to refer to hardware elements in the semantic
; code.  Usually there's a bit of over-specification, but in more complicated
; instruction sets there isn't.

(dnop sr        "status register"               ()         h-sr        f-nil)
(dnop ssr_fiq   "saved status register (fiq)"   ()         h-ssr_fiq   f-nil)
(dnop spc_fiq   "saved program counter (fiq)"   ()         h-ssr_fiq   f-nil)
(dnop ssr_irq   "saved status register (irq)"   ()         h-ssr_irq   f-nil)
(dnop spc_irq   "saved program counter (irq)"   ()         h-ssr_irq   f-nil)
(dnop ssr_swi   "saved status register (swi)"   ()         h-ssr_swi   f-nil)
(dnop spc_swi   "saved program counter (swi)"   ()         h-ssr_swi   f-nil)
(dnop ssr_expt  "saved status register (expt)"  ()         h-ssr_expt  f-nil)
(dnop spc_expt  "saved program counter (expt)"  ()         h-ssr_expt  f-nil)
(dnop vbr       "vector base register"          ()         h-vbr       f-nil)
(dnop rd-8-10   "rd [8:10]"                     ()         h-d         f-rd-8-10)
(dnop rd-8-11   "rd [8:11]"                     ()         h-r         f-rd-8-11)
(dnop rd-0-2    "rd [0:2]"                      ()         h-d         f-rd-0-2)
(dnop rd-0-3    "rd [0:3]"                      ()         h-r         f-rd-0-3)
(dnop rd-4-6    "rd [4:6]"                      ()         h-d         f-rd-4-6)
(dnop rd-4-7    "rd [4:7]"                      ()         h-r         f-rd-4-7)
(dnop imm-2     "imm 2"                         ()         h-uint      f-imm-2)
(dnop imm-3     "imm 3"                         ()         h-imm-3     f-imm-3)
(dnop ldrsbs3   "ls rsbs imm:3"                 ()         h-uint      f-ldrsbs3)
(dnop imm-4     "imm 4"                         ()         h-uint      f-imm-4)
(dnop imm-5     "imm 5"                         ()         h-uint      f-imm-5)
(dnop imm-7     "imm 7"                         ()         h-uint      f-imm-7)
(dnop imm-8     "imm 8"                         ()         h-uint      f-imm-8)
(dnop imm-13    "imm 13"                        ()         h-uint      f-imm-13)
(dnop imm-17    "imm 17"                        ()         h-sint      f-imm-17)
(dnop imm-32    "imm 32"                        ()         h-sint      f-imm-32)
(dnop rs-0-2    "rs [0:2]"                      ()         h-d         f-rs-0-2)
(dnop rs-0-3    "rs [0:3]"                      ()         h-r         f-rs-0-3)
(dnop rs-4-6    "rs [4:6]"                      ()         h-d         f-rs-4-6)
(dnop rs-4-7    "rs [4:7]"                      ()         h-d         f-rs-4-7)
(dnop rs-8-10   "rs [8:10]"                     ()         h-a         f-rs-8-10)
(dnop divi-rs1  "divi-rs1"                      ()         h-d         f-divi-rs1)
(dnop divi-rs2  "divi-rs1"                      ()         h-d         f-divi-rs2)
(dnop rs1       "rs1"                           ()         h-a         f-rs1)
(dnop rs2       "rs1"                           ()         h-d         f-rs2)
(dnop bs-3      "bs:3"                          ()         h-uint      f-bs-3)
(dnop bs-5      "bs:5"                          ()         h-bs-5      f-bs-5)
(dnop offset-8  "offset:8"                      ()         h-iaddr     f-offset-8)
(dnop offset-9  "offset:9"                      ()         h-iaddr     f-offset-9)
(dnop offset-10 "offset:10"                     ()         h-iaddr     f-offset-10)
(dnop offset-11 "offset:11"                     ()         h-iaddr     f-offset-11)
(dnop offset-23 "offset:23"                     (FOUR-BYTE) h-iaddr    f-offset-23)
(dnop H-4       "h:4"                           ()         h-H-4       f-H-4)
(dnop H-8       "h:8"                           ()         h-uint      f-H-8)
(dnop ec        "ec"                            ()         h-ec        f-ec)
(dnop crs-4-8   "crs [4:8]"                     ()         h-cr        f-crs-4-8)
(dnop crs-4-7   "crs [4:7]"                     ()         h-cr-half   f-crs-4-7)
(dnop crd-4-8   "crd [4:8]"                     ()         h-cr        f-crd-4-8)
(dnop crd-4-7   "crd [4:7]"                     ()         h-cr-half   f-crd-4-7)
(dnop rb-8-9    "rb [8:9]"                      ()         h-b         f-rb-8-9)
(dnop rb-0-1    "rb [0:1]"                      ()         h-b         f-rb-0-1)
(dnop ro        "ro"                            ()         h-t         f-ro)
(dnop cld-disp-4 "cld disp:4"                   ()         h-uint      f-cld-disp-4)
(dnop ldh-disp-4 "ldh disp:4"                   ()         h-uint      f-ldh-disp-4)
(dnop disp-4    "disp:4"                        ()         h-uint      f-disp-4)
(dnop disp-6    "disp:6"                        ()         h-uint      f-disp-6)
(dnop disp-8    "disp:8"                        ()         h-uint      f-disp-8)
(dnop P         "P"                             ()         h-uint      f-P)
(dnop D         "D"                             ()         h-uint      f-D)
(dnop spr       "spr"                           ()         h-spr       f-spr)
(dnop s-8       "s-8"                           ()         h-uint      f-s-8)
(dnop s-11      "s-11"                          ()         h-uint      f-s-11)
(dnop sssd      "sssd"                          ()         h-sssd      f-sssd)
(dnop qq        "qq"                            ()         h-qq        f-qq)
(dnop swi_no    "swi_no"                        ()         h-uint      f-swi_no)

; status register bits
(dnop tbit      "true bit"                      (SEM-ONLY) h-tbit      f-nil)
(dnop vbit      "overflow bit"                  (SEM-ONLY) h-vbit      f-nil)
(dnop z0bit     "zero r6 bnzd bit"              (SEM-ONLY) h-z0bit     f-nil)
(dnop z1bit     "zero r7 bnzd bit"              (SEM-ONLY) h-z1bit     f-nil)
(dnop dsbit     "divisors sign bit"             (SEM-ONLY) h-dsbit     f-nil)
(dnop qtbit     "quotient bit"                  (SEM-ONLY) h-qtbit     f-nil)
(dnop bxbit     "ldb sign/zero ext bit"         (SEM-ONLY) h-bxbit     f-nil)
(dnop hxbit     "ldh sign/zero ext bit"         (SEM-ONLY) h-hxbit     f-nil)
(dnop sysx      "system interface bits"         (SEM-ONLY) h-sysx      f-nil)
(dnop iebit     "enable irq bit"                (SEM-ONLY) h-iebit     f-nil)
(dnop febit     "enable fiq bit"                (SEM-ONLY) h-febit     f-nil)
(dnop tebit     "enable trace bit"              (SEM-ONLY) h-tebit     f-nil)
(dnop bsbit     "bank select bit"               (SEM-ONLY) h-bsbit     f-nil)
(dnop rs0bit    "register select bit 0"         (SEM-ONLY) h-rs0bit    f-nil)
(dnop rs1bit    "register select bit 1"         (SEM-ONLY) h-rs1bit    f-nil)
(dnop pmbit     "processor mode bit"            (SEM-ONLY) h-pmbit     f-nil)
(dnop ecbits    "external condition bits"       (SEM-ONLY) h-ecbits    f-nil)



; Instruction definitions.
;
; Notes while wip:
; - dni is a cover macro to the real "this is an instruction" keyword.
;   The syntax of the real one is yet to be determined.
;   At the lowest level (i.e. the "real" one) it will probably take a variable
;   list of arguments where each argument [perhaps after the standard three of
;   name, comment, attrs] is "(keyword arg-to-keyword)".  This syntax is simple
;   and yet completely upward extensible.  And given the macro facility, one
;   needn't code at that low a level so even though it'll be more verbose than
;   necessary it won't matter.  This same reasoning can be applied to most
;   types of entries in this file.

; Useful macros
(define-pmacro (set-z reg)
  (if (eq (index-of reg) 6)
      (set z0bit (eq reg 0))
      (if (eq (index-of reg) 7)
          (set z1bit (eq reg 0))))
)

(define-pmacro (add-op name comment syntax format src extra)
  (begin
    (dni (name)
         (comment)
         ()
         (syntax)
         format
         (sequence ((SI result))
           (set result (addc rd-8-11 src extra))
           (set tbit (add-cflag SI rd-8-11 src extra))
           (set vbit (add-oflag SI rd-8-11 src extra))
           (set rd-8-11 result)
           (set-z rd-8-11))
         ()
    )
  )
)

; add with immediate
(add-op addimm
     "add rd,#imm:7"
     "add ${rd-8-11},#${imm-7}"
     (+ OP1_A rd-8-11 (f-bit-7 0) imm-7)
     (zext SI imm-7) (const 0)
)

; add
(add-op add
     "add rd,rs"
     "add ${rd-8-11},${rs-0-3}"
     (+ OP1_8 rd-8-11 OP3_0 rs-0-3)
     rs-0-3 (const 0)
)

; add with carry
(add-op adc
     "adc rd,rs"
     "adc ${rd-8-11},${rs-0-3}"
     (+ OP1_8 rd-8-11 OP3_4 rs-0-3)
     rs-0-3 tbit
)

(dni (andimm)
     ("and r0,#imm:8")
     ()
     ("and r0,#${imm-8}")
     (+ OP1_9 OP2_4 imm-8)
     (sequence ((SI result))
       (set result (and (reg SI h-r 0) (zext SI imm-8)))
       (set (reg SI h-r 0) result)
       (set tbit (zflag SI result)))
     ()
)

(dni (and)
     ("and rd,rs")
     ()
     ("and ${rd-8-11},${rs-0-3}")
     (+ OP1_8 OP3_2 rd-8-11 rs-0-3)
     (sequence ((SI result))
       (set result (and rd-8-11 rs-0-3))
       (set rd-8-11 result)
       (set tbit (zflag SI result))
       (set-z rd-8-11))
     ()
)

(dni (bitc)
     ("bitc @[r8+r1], bs:3")
     ()
     ("bitc @[r8+r1],${bs-3}")
     (+ OP1_9 OP2_C OP3_5 (f-bit-3 1) bs-3)
     (sequence ((QI buffer))
       (set buffer (mem QI (add (reg h-r 8) (reg h-r 1))))
       (set tbit (and buffer (sll QI 1 bs-3)))
       (set buffer (xor buffer (sll QI 1 bs-3)))
       (set (mem QI (add (reg h-r 8) (reg h-r 1))) buffer))
     ()
)

(dni (bitr)
     ("bitr @[r8+r1], bs:3")
     ()
     ("bitr @[r8+r1],${bs-3}")
     (+ OP1_9 OP2_C OP3_4 (f-bit-3 0) bs-3)
     (sequence ((QI buffer))
       (set buffer (mem QI (add (reg h-r 8) (reg h-r 1))))
       (set tbit (and buffer (sll QI 1 bs-3)))
       (set buffer (and buffer (inv QI (sll QI 1 bs-3))))
       (set (mem QI (add (reg h-r 8) (reg h-r 1))) buffer))
     ()
)

(dni (bits)
     ("bits @[r8+r1], bs:3")
     ()
     ("bits @[r8+r1],${bs-3}")
     (+ OP1_9 OP2_C OP3_4 (f-bit-3 1) bs-3)
     (sequence ((QI buffer))
       (set buffer (mem QI (add (reg h-r 8) (reg h-r 1))))
       (set tbit (and buffer (sll QI 1 bs-3)))
       (set buffer (or buffer (sll QI 1 bs-3)))
       (set (mem QI (add (reg h-r 8) (reg h-r 1))) buffer))
     ()
)

(dni (bitt)
     ("bitt @[r8+r1], bs:3")
     ()
     ("bitt @[r8+r1],${bs-3}")
     (+ OP1_9 OP2_C OP3_5 (f-bit-3 0) bs-3)
     (sequence ((QI buffer))
       (set buffer (mem QI (add (reg h-r 8) (reg h-r 1))))
       (set tbit (and buffer (sll QI 1 bs-3))))
     ()
)

; delay slot
(define-pmacro (bnzd-op ix z hbit)
  (begin
    (dni (.sym "bnzd-r" ix)
         (.str "bnzd r" ix ", offset:8")
         ()
         (.str "bnzd r" ix ",${offset-8}")
         (+ OP1_C (f-b9-11 3) (f-H-8 hbit) offset-8)
         (sequence ()
           (if (not (.sym z "bit"))
             (sequence ()
               (set (reg SI h-r ix) (sub (reg SI h-r ix) 1))
               (set (.sym z "bit") (zflag SI (reg SI h-r ix)))
               (set (delay 1 pc) (add 2 (add pc (ext SI offset-8)))))))
         ()
    )
  )
)

(bnzd-op 6 "z0" 0)
(bnzd-op 7 "z1" 1)

; delay slot
(dni (brad)
     ("brad offset:10")
     ()
     ("brad ${offset-10}")
     (+ OP1_D (f-b10-11 0) offset-10)
     (set (delay 1 pc) (add 2 (add pc (ext SI offset-10))))
     ()
)

(dni (bral)
     ("bral offset:23")
     ()
     ("bral ${offset-23}")
     (+ OP1_C OP2_3 (f-bit-7 0) offset-23)
     (set pc (add 4 (add pc (ext SI offset-23))))
     ()
)

; delay slot
(dni (brd)
     ("brd ec,offset:8")
     ()
     ("brd $ec,${offset-8}")
     (+ OP1_D (f-b10-11 1) ec offset-8)
     (if (xor ec ecbits)
       (set (delay 1 pc) (add 2 (add pc (ext SI offset-8)))))
     ()
)

(dni (break)
     ("break")
     ()
     ("break")
     (+ OP1_9 OP2_E OP3_4 OP4_F)
     ; used by the debugger
     (c-call VOID "do_break" pc)
     ()
)

(dni (brf)
     ("brf offset:9")
     ()
     ("brf ${offset-9}")
     (+ OP1_C (f-b9-11 0) offset-9)
     (if (not tbit)
       (set pc (add 2 (add pc (ext SI offset-9)))))
     ()
)

; delay slot
(dni (brfd)
     ("brfd offset:10")
     ()
     ("brfd ${offset-10}")
     (+ OP1_C (f-b10-11 2) offset-10)
     (if (not tbit)
       (set (delay 1 pc) (add 2 (add pc (ext SI offset-10)))))
     ()
)

(dni (brt)
     ("brt offset:9")
     ()
     ("brt ${offset-9}")
     (+ OP1_C (f-b9-11 2) offset-9)
     (if tbit
       (set pc (add 2 (add pc (ext SI offset-9)))))
     ()
)

; delay slot
(dni (brtd)
     ("brtd offset:10")
     ()
     ("brtd ${offset-10}")
     (+ OP1_C (f-b10-11 3) offset-10)
     (if tbit
       (set (delay 1 pc) (add 2 (add pc (ext SI offset-10)))))
     ()
)

; delay slot
(dni (bsrd)
     ("bsrd offset:11")
     ()
     ("bsrd ${offset-11}")
     (+ OP1_D (f-bit-11 1) offset-11)
     (sequence ()
       (set (reg h-r 14) (add pc 4))
       (set (delay 1 pc) (add 2 (add pc (ext SI offset-11)))))
     ()
)

(dni (bsrl)
     ("bsrl offset:23")
     ()
     ("bsrl ${offset-23}")
     (+ OP1_C OP2_3 (f-bit-7 1) offset-23)
     (sequence ()
       (set (reg h-r 14) (add pc 4))
       (set pc (add 4 (add pc (ext SI offset-23)))))
     ()
)

; XXX no insn semantics yet
(dni (cld)
     ("cld rd,crs")
     ()
     ("cld ${rd-0-2},${crs-4-8}")
     (+ OP1_E (f-b9-11 0) crs-4-8 (f-bit-3 0) rd-0-2)
     (nop)
     ()
)

; XXX no insn semantics yet
(dni (cldrev)
     ("cld crd,rs")
     ()
     ("cld ${crd-4-8},${rs-0-2}")
     (+ OP1_E (f-b9-11 0) crd-4-8 (f-bit-3 1) rs-0-2)
     (nop)
     ()
)

; XXX no insn semantics yet
(dni (cldmemreg)
     ("cld crd,@[rb+rt]")
     ()
     ("cld ${crd-4-7},@[${rb-8-9}+${ro}]")
     (+ OP1_E (f-b10-11 1) rb-8-9 crd-4-7 (f-b2-3 1) ro)
     (nop)
     ()
)

; XXX no insn semantics yet
(dni (cldrevmemreg)
     ("cld @[rb+rt],crs")
     ()
     ("cld @[${rb-8-9}+${ro}],${crs-4-7}")
     (+ OP1_E (f-b10-11 1) rb-8-9 crs-4-7 (f-b2-3 3) ro)
     (nop)
     ()
)

; XXX no insn semantics yet
(dni (cldmem)
     ("cld crd,@[rb+disp:4]")
     ()
     ("cld ${crd-4-7},@[${rb-8-9}+${cld-disp-4}]")
     (+ OP1_E (f-b10-11 2) rb-8-9 crd-4-7 cld-disp-4)
     (nop)
     ()
)

; XXX no insn semantics yet
(dni (cldrevmem)
     ("cld @[rb+disp:4],crs")
     ()
     ("cld @[${rb-8-9}+${cld-disp-4}],${crd-4-7}")
     (+ OP1_E (f-b10-11 3) rb-8-9 crs-4-7 cld-disp-4)
     (nop)
     ()
)

; XXX no insn semantics yet
(define-pmacro (cld-from-op name what sem Pbit Dbit)
  (begin
    (dni (.sym name)
         (.str "cld crd,@" name)
         ()
         (.str "cld ${crd-4-7},@" sem)
         (+ OP1_E (f-b10-11 1) (f-P Pbit) (f-D Dbit) crd-4-7 (f-b2-3 0) rb-0-1)
         (nop)
         ()
    )
  )
)

(cld-from-op cldfrompredec  "-rb" "-${rb-0-1}" 1 1)
(cld-from-op cldfrompreinc  "+rb" "+${rb-0-1}" 1 0)
(cld-from-op cldfrompostdec "rb-" "${rb-0-1}-" 0 1)
(cld-from-op cldfrompostinc "rb+" "${rb-0-1}+" 0 0)

; XXX no insn semantics yet
(define-pmacro (cld-to-op name what sem Pbit Dbit)
  (begin
    (dni (.sym name)
         (.str "cld @" name ",crs")
         ()
         (.str "cld @" sem ",${crs-4-7}")
         (+ OP1_E (f-b10-11 1) (f-P Pbit) (f-D Dbit) crs-4-7 (f-b2-3 2) rb-0-1)
         (nop)
         ()
    )
  )
)

(cld-to-op "cldtopredec"  "-rb" "-${rb-0-1}" 1 1)
(cld-to-op "cldtopreinc"  "+rb" "+${rb-0-1}" 1 0)
(cld-to-op "cldtopostdec" "rb-" "${rb-0-1}-" 0 1)
(cld-to-op "cldtopostinc" "rb+" "${rb-0-1}+" 0 0)

(dni (clrsr)
     ("clrsr bs:5")
     ()
     ("clrsr ${bs-5}")
     (+ OP1_9 OP2_E (f-b5-7 5) bs-5)
     (cond
       ((eq bs-5 0) (set tbit 0))
       ((eq bs-5 3) (set vbit 0))
       ((eq bs-5 4) (set z0bit 0))
       ((eq bs-5 5) (set z1bit 0))
       ((eq bs-5 6) (set dsbit 0))
       ((eq bs-5 7) (set qtbit 0))
       ((eq bs-5 12) (set bxbit 0))
       ((eq bs-5 13) (set hxbit 0))
       ((eq bs-5 16) (set sysx (and sysx (const #xe))))
       ((eq bs-5 17) (set sysx (and sysx (const #xd))))
       ((eq bs-5 18) (set sysx (and sysx (const #xb))))
       ((eq bs-5 19) (set sysx (and sysx (const #x7))))
       ((eq bs-5 24) (set iebit 0))
       ((eq bs-5 25) (set febit 0))
       ((eq bs-5 26) (set tebit 0))
       ((eq bs-5 28) (set bsbit 0))
       ((eq bs-5 29) (set rs0bit 0))
       ((eq bs-5 30) (set rs1bit 0))
       ((eq bs-5 31) (set pmbit 0)))
     ()
)

(dni (cmpeqimm)
     ("cmp eq rs,#imm:8")
     ()
     ("cmp eq ${rd-8-11},#${imm-8}")
     (+ OP1_4 rd-8-11 imm-8)
     (set tbit (eq rd-8-11 (zext SI imm-8)))
     ()
)

(dni (cmpgeimm)
     ("cmp ge rs,#imm:8")
     ()
     ("cmp ge ${rd-8-11},#${imm-8}")
     (+ OP1_5 rd-8-11 imm-8)
     (set tbit (ge rd-8-11 (zext SI imm-8)))
     ()
)

(define-pmacro (cmp-op name op what op3 mode)
  (begin
    (dni (name)
         (.str what " rd,rs")
         ()
         (.str what " ${rd-8-11},${rs-0-3}")
         (+ OP1_8 op3 rd-8-11 rs-0-3)
         (set tbit (op mode rd-8-11 rs-0-3))
         ()
    )
  )
)

(cmp-op cmpeq  eq  "cmp eq"  OP3_A SI)
(cmp-op cmpge  ge  "cmp ge"  OP3_8 SI)
(cmp-op cmpgt  gt  "cmp gt"  OP3_9 SI)
(cmp-op cmpuge geu "cmpu ge" OP3_C USI)
(cmp-op cmpugt gtu "cmpu gt" OP3_D USI)

(dni (com)
     ("com rd")
     ()
     ("com ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_6 rd-0-3)
     (sequence ((USI result))
       (set result (inv USI rd-0-3))
       (set tbit (eq 0 result))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dni (com2)
     ("com2 rd")
     ()
     ("com2 ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_7 rd-0-3)
     (sequence ((USI result))
       (set result (add (inv USI rd-0-3) 1))
       (set rd-0-3 result)
       (set-z rd-0-3)
       (set tbit (eq 0 result)))
     ()
)

(dni (comc)
     ("comc rd")
     ()
     ("comc ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_3 rd-0-3)
     (sequence ((USI result))
       (set result (add (inv USI rd-0-3) tbit))
       (set rd-0-3 result)
       (set-z rd-0-3)
       (set tbit (eq 0 result)))
     ()
)

; XXX no insn semantics yet
(dni (cop)
     ("cop imm:13")
     ()
     ("cop #${imm-13}")
     (+ (f-b13-15 7) imm-13)
     (nop)
     ()
)

(dni (decf)
     ("decf rd")
     ()
     ("decf ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_4 rd-0-3)
     (sequence ((SI result) (BI decr))
       (set decr (sub 1 tbit))
       (set result (sub rd-0-3 decr))
       (set tbit (sub-cflag SI rd-0-3 decr (const 0)))
       (set vbit (sub-oflag SI rd-0-3 decr (const 0)))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dnmi decc "decc rd"
     (NO-DIS)
     ("decc ${rd-0-3}")
     (emit decf rd-0-3)
)

(dni (dect)
     ("dect rd")
     ()
     ("dect ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_0 rd-0-3)
     (sequence ((SI result) (BI decr))
       (set decr (sub 1 (not tbit)))
       (set result (sub rd-0-3 decr))
       (set tbit (sub-cflag SI rd-0-3 decr (const 0)))
       (set vbit (sub-oflag SI rd-0-3 decr (const 0)))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dni (div1)
     ("div1 rd,rs")
     ()
     ("div1 ${rd-0-2},${rs-4-6}")
     (+ OP1_9 OP2_C (f-bit-7 1) rs-4-6 (f-bit-3 0) rd-0-2)
     (sequence ((BI old-qt) (BI tmp-qt) (SI dividend) (SI divisor) (SI result))
       (set old-qt qtbit)
       (set tmp-qt (and rd-0-2 #x80000000))
       (set dividend (or (sll rd-0-2 1) tbit))
       (set divisor rs-4-6)
       (if (eq old-qt 0)
         (if (eq dsbit 0)
           (sequence ()
             (set result (sub dividend divisor))
             (if (not tmp-qt)
              (set qtbit (gt result dividend))
              (set qtbit (not (gt result dividend)))))
           (sequence ()
             (set result (add dividend divisor))
             (if (not tmp-qt)
               (set qtbit (lt result dividend))
               (set qtbit (not (lt result dividend))))))
         (if (eq dsbit 0)
           (sequence ()
             (set result (add dividend divisor))
             (if (not tmp-qt)
               (set qtbit (not (lt result dividend)))
               (set qtbit (lt result dividend))))
           (sequence ()
             (set result (sub dividend divisor))
             (if (not tmp-qt)
               (set qtbit (not (gt result dividend)))
               (set qtbit (gt result dividend))))))
       (set rd-0-2 dividend)
       (set tbit (eq qtbit dsbit)))
     ()
)

(dni (divi)
     ("divi rs1,rs2")
     ()
     ("divi ${divi-rs1},${divi-rs2}")
     (+ OP1_9 OP2_C (f-bit-7 1) divi-rs1 (f-bit-3 1) divi-rs2)
     (sequence ()
       (set qtbit (and (srl divi-rs1 31) 1))
       (set dsbit (and (srl divi-rs2 31) 1))
       (set tbit (xor qtbit dsbit)))
     ()
)

(dni (diviu)
     ("diviu")
     ()
     ("diviu")
     (+ OP1_9 OP2_E OP3_4 OP4_C)
     (sequence ()
       (set qtbit (const 0))
       (set dsbit (const 0))
       (set tbit (const 0)))
     ()
)

(dni (dt)
     ("dt rd")
     ()
     ("dt ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_2 rd-0-3)
     (sequence ((SI result))
       (set result (sub rd-0-3 1))
       (set tbit (eq result (const 0)))
       (set vbit (sub-oflag SI rd-0-3 1 (const 0)))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dni (incf)
     ("incf rd")
     ()
     ("incf ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_5 rd-0-3)
     (sequence ((SI result) (BI incr))
       (set incr (sub 1 tbit))
       (set result (add rd-0-3 incr))
       (set tbit (add-cflag SI rd-0-3 incr (const 0)))
       (set vbit (add-oflag SI rd-0-3 incr (const 0)))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dni (inct)
     ("inct rd")
     ()
     ("inct ${rd-0-3}")
     (+ OP1_9 OP2_0 OP3_1 rd-0-3)
     (sequence ((SI result) (BI incr))
       (set incr tbit)
       (set result (add rd-0-3 incr))
       (set tbit (add-cflag SI rd-0-3 incr (const 0)))
       (set vbit (add-oflag SI rd-0-3 incr (const 0)))
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dnmi incc "incc rd"
     (NO-DIS)
     ("incc ${rd-0-3}")
     (emit inct rd-0-3)
)

; delay slot
(dni (jmpd)
     ("jmpd rs")
     ()
     ("jmpd ${rs-0-3}")
     (+ OP1_9 OP2_F OP3_0 rs-0-3)
     (set (delay 1 pc) rs-0-3)
     ()
)

; delay slot
(dni (jpfd)
     ("jpfd rs")
     ()
     ("jpfd ${rs-0-3}")
     (+ OP1_9 OP2_F OP3_2 rs-0-3)
     (if (not tbit) (set (delay 1 pc) rs-0-3))
     ()
)

; delay slot
(dni (jptd)
     ("jptd rs")
     ()
     ("jptd ${rs-0-3}")
     (+ OP1_9 OP2_F OP3_3 rs-0-3)
     (if tbit (set (delay 1 pc) rs-0-3))
     ()
)

; delay slot
(dni (jsrd)
     ("jsrd rs")
     ()
     ("jsrd ${rs-0-3}")
     (+ OP1_9 OP2_F OP3_1 rs-0-3)
     (sequence ()
       (set (reg SI h-r 14) (add pc 4))
       (set (delay 1 pc) rs-0-3))
     ()
)

(dni (ldch)
     ("ldch rd,@rs")
     ()
     ("ldch ${rd-0-2},@${rs-4-7}")
     (+ OP1_9 OP2_D rs-4-7 (f-bit-3 0) rd-0-2)
     (c-call VOID "do_ldch" (index-of rd-0-2) (index-of rs-4-7))
     ()
)

(dni (ldcw)
     ("ldcw rd,@rs")
     ()
     ("ldcw ${rd-0-2},@${rs-4-7}")
     (+ OP1_9 OP2_D rs-4-7 (f-bit-3 1) rd-0-2)
     (c-call VOID "do_ldcw" (index-of rd-0-2) (index-of rs-4-7))
     ()
)

; merge ldspr & ldsprrev ?
(dni (ldspr)
     ("ld r0,spr")
     ()
     ("ld r0,$spr")
     (+ OP1_9 OP2_E OP3_6 spr)
     (set SI
       (reg SI h-r 0)
       (cond SI
         ((eq spr 0) sr)
         ((eq spr 1) vbr)
         ((eq spr 8) ssr_fiq)
         ((eq spr 9) ssr_irq)
         ((eq spr 10) ssr_swi)
         ((eq spr 11) ssr_expt)
         ((eq spr 12) spc_fiq)
         ((eq spr 13) spc_irq)
         ((eq spr 14) spc_swi)
         ((eq spr 15) spc_expt)
         (else (reg SI h-r 0)))) ; XXX
     ()
)

(dni (ldsprrev)
     ("ld spr,r0")
     ()
     ("ld $spr,r0")
     (+ OP1_9 OP2_E OP3_7 spr)
     (sequence ((SI tmp))
       (cond
         ((eq spr 0) (set sr (reg SI h-r 0)))
         ((eq spr 1) (set vbr (reg SI h-r 0)))
         ((eq spr 8) (set ssr_fiq (reg SI h-r 0)))
         ((eq spr 9) (set ssr_irq (reg SI h-r 0)))
         ((eq spr 10) (set ssr_swi (reg SI h-r 0)))
         ((eq spr 11) (set ssr_expt (reg SI h-r 0)))
         ((eq spr 12) (set spc_fiq (reg SI h-r 0)))
         ((eq spr 13) (set spc_irq (reg SI h-r 0)))
         ((eq spr 14) (set spc_swi (reg SI h-r 0)))
         ((eq spr 15) (set spc_expt (reg SI h-r 0)))
         (else (set (reg SI h-r 0) (reg SI h-r 0))))) ; XXX
     ()
)

(dni (ldfeie)
     ("ld feie,#imm:2")
     ()
     ("ld feie,#${imm-2}")
     (+ OP1_9 OP2_E OP3_F (f-b2-3 0) imm-2)
     (sequence ()
       (set febit (not (not (and imm-2 2))))
       (set iebit (not (not (and imm-2 1)))))
     ()
)

(dni (ldrsbs)
     ("ld rsbs,#imm:3")
     ()
     ("ld rsbs,#${ldrsbs3}")
     (+ OP1_9 OP2_E OP3_F (f-bit-3 1) ldrsbs3)
     (sequence ()
       (set rs1bit (not (not (and ldrsbs3 4))))
       (set rs0bit (not (not (and ldrsbs3 2))))
       (set bsbit (not (not (and ldrsbs3 1)))))
     ()
)

(dni (ld8)
     ("ld rd,#imm:8")
     ()
     ("ld ${rd-8-11},#${imm-8}")
     (+ OP1_B rd-8-11 imm-8)
     (sequence ((UQI result))
       (set result imm-8)
       (set rd-8-11 result)
       (set-z rd-8-11))
     ()
)

(dni (ld16)
     ("ldh rd,#imm:16")
     ()
     ("ldh ${rd-0-3},#${imm-17}")
     (+ OP1_9 OP2_1 (f-b6-7 1) (f-bit-4 1) rd-0-3 imm-17)
     (sequence ()
     ; need to manually sign/zero extend the 17-bit number.
       (if (and imm-17 (const #x10000))
         (set rd-0-3 (or SI (and imm-17 (const #xffff)) (const #xffff0000)))
         (set SI rd-0-3 (and imm-17 (const #xffff))))
       (set-z rd-0-3))
     ()
)

(dni (ld32)
     ("ldw rd,#imm:32")
     ()
     ("ldw ${rd-0-3},#${imm-32}")
     (+ OP1_9 OP2_1 OP3_6 rd-0-3 imm-32)
     (sequence ((SI result))
       (set result imm-32)
       (set rd-0-3 result)
       (set-z rd-0-3))
     ()
)

(dni (ldb)
     ("ldb rd,@[rs1+rs2]")
     ()
     ("ldb ${rd-4-6},@[$rs1+$rs2]")
     (+ OP1_6 (f-s-11 0) rs1 (f-bit-7 0) rd-4-6 (f-bit-3 0) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set rd-4-6 (if SI bxbit
                     (ext SI (mem QI eff-addr))
                     (zext SI (mem UQI eff-addr)))))
     ()
)

(dni (ldbrev)
     ("ldb @[rs1+rs2],rd")
     ()
     ("ldb @[$rs1+$rs2],${rd-4-6}")
     (+ OP1_6 (f-s-11 1) rs1 (f-bit-7 0) rd-4-6 (f-bit-3 0) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set UQI (mem UQI eff-addr) rd-4-6))
     ()
)

(dnmi stbrev "stb @[rs1+rs2],rd"
     (NO-DIS)
     ("stb @[$rs1+$rs2],${rd-4-6}")
     (emit ldbrev rs1 rs2 rd-4-6)
)

(dni (ldbmem)
     ("ldb rd,@[rs+disp:4]")
     ()
     ("ldb ${rd-4-6},@[${rs-8-10}+${disp-4}]")
     (+ OP1_7 (f-s-11 0) rs-8-10 (f-bit-7 0) rd-4-6 disp-4)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI disp-4)))
       (set rd-4-6 (if SI bxbit
         (ext SI (mem QI eff-addr))
         (zext USI (mem UQI eff-addr)))))
     ()
)

(dni (ldbmemrev)
     ("ldb @[rs+disp:4],rd")
     ()
     ("ldb @[${rs-8-10}+${disp-4}],${rd-4-6}")
     (+ OP1_7 (f-s-11 1) rs-8-10 (f-bit-7 0) rd-4-6 disp-4)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI disp-4)))
       (set UQI (mem UQI eff-addr) rd-4-6))
     ()
)

(dnmi stbmemrev "stb @[rs+disp:4],rd"
     (NO-DIS)
     ("stb @[${rs-8-10}+${disp-4}],${rd-4-6}")
     (emit ldbmemrev rs-8-10 disp-4 rd-4-6)
)

(dni (ldblong)
     ("ldb r0,@[r8+disp:8]")
     ()
     ("ldb r0,@[r8+${disp-8}]")
     (+ OP1_9 OP2_8 disp-8)
     (sequence ((USI eff-addr))
       (set eff-addr (add (reg h-r 8) (zext USI disp-8)))
       (set (reg h-r 0) (if SI bxbit
                     (ext SI (mem QI eff-addr))
                     (zext SI (mem UQI eff-addr)))))
     ()
)

(dni (ldblongrev)
     ("ldb @[r8+disp:8],r0")
     ()
     ("ldb @[r8+${disp-8}],r0")
     (+ OP1_9 OP2_9 disp-8)
     (sequence ((USI eff-addr))
       (set eff-addr (add (reg h-r 8) (zext USI disp-8)))
       (set UQI (mem UQI eff-addr) (reg h-r 0)))
     ()
)

(dnmi stblongrev "stb @[r8+disp:8],r0"
     (NO-DIS)
     ("stb @[r8+${disp-8}],r0")
     (emit ldblongrev disp-8)
)

(dni (ldh)
     ("ldh rd,@[rs1+rs2]")
     ()
     ("ldh ${rd-4-6},@[$rs1+$rs2]")
     (+ OP1_6 (f-s-11 0) rs1 (f-bit-7 1) rd-4-6 (f-bit-3 0) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set rd-4-6 (if SI hxbit
                     (ext SI (mem HI eff-addr))
                     (zext SI (mem UHI eff-addr)))))
     ()
)

(dni (ldhrev)
     ("ldh @[rs1+rs2],rd")
     ()
     ("ldh @[$rs1+$rs2],${rd-4-6}")
     (+ OP1_6 (f-s-11 1) rs1 (f-bit-7 1) rd-4-6 (f-bit-3 0) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set UHI (mem UHI eff-addr) rd-4-6))
     ()
)

(dnmi sthrev "sth @[rs1+rs2],rd"
     (NO-DIS)
     ("sth @[$rs1+$rs2],${rd-4-6}")
     (emit ldhrev rs1 rs2 rd-4-6)
)

(dni (ldhmem)
     ("ldh rd,@[rs+disp:4]")
     ()
     ("ldh ${rd-4-6},@[${rs-8-10}+${ldh-disp-4}]")
     (+ OP1_7 (f-s-11 0) rs-8-10 (f-bit-7 1) rd-4-6 ldh-disp-4)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI ldh-disp-4)))
       (set rd-4-6 (if SI hxbit
                     (ext SI (mem HI eff-addr))
                     (zext SI (mem UHI eff-addr)))))
     ()
)

(dni (ldhmemrev)
     ("ldh @[rs1+disp:4],rd")
     ()
     ("ldh @[${rs-8-10}+${ldh-disp-4}],${rd-4-6}")
     (+ OP1_7 (f-s-11 1) rs-8-10 (f-bit-7 1) rd-4-6 ldh-disp-4)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI ldh-disp-4)))
       (set UHI (mem UHI eff-addr) rd-4-6))
     ()
)

(dnmi sthmemrev "sth @[rs1+disp:4],rd"
     (NO-DIS)
     ("sth @[${rs-8-10}+${ldh-disp-4}],${rd-4-6}")
     (emit ldhmemrev rs-8-10 ldh-disp-4 rd-4-6)
)

(dni (ldpc)
     ("ld rd,pc")
     ()
     ("ld ${rd-0-3},pc")
     (+ OP1_9 OP2_E OP3_2 rd-0-3)
     (set rd-0-3 (add pc 4))
     ()
)

(dni (ld)
     ("ld rd,rs")
     ()
     ("ld ${rd-8-11},${rs-0-3}")
     (+ OP1_8 rd-8-11 OP3_F rs-0-3)
     (sequence ((SI result))
       (set result rs-0-3)
       (set rd-8-11 result)
       (set-z rd-8-11))
     ()
)

(dni (ldsysx)
     ("ld sysx,#imm:4")
     ()
     ("ld sysx,${imm-4}")
     (+ OP1_9 OP2_E OP3_E imm-4)
     (set sysx imm-4)
     ()
)

(dni (ldw)
     ("ldw rd,@[rs1+rs2]")
     ()
     ("ldw ${rd-4-7},@[$rs1+$rs2]")
     (+ OP1_6 (f-s-11 0) rs1 rd-4-7 (f-bit-3 1) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set rd-4-7 (mem USI eff-addr)))
     ()
)

(dni (ldwrev)
     ("ldw @[rs1+rs2],rd")
     ()
     ("ldw @[$rs1+$rs2],${rd-4-7}")
     (+ OP1_6 (f-s-11 1) rs1 rd-4-7 (f-bit-3 1) rs2)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs1 rs2))
       (set (mem USI eff-addr) rd-4-7))
     ()
)

(dnmi stwrev "stw @[rs1+rs2],rd"
     (NO-DIS)
     ("stw @[$rs1+$rs2],${rd-4-7}")
     (emit ldwrev rs1 rs2 rd-4-7)
)

(dni (ldwmem)
     ("ldw rd,@[rs+disp:6]")
     ()
     ("ldw ${rd-4-7},@[${rs-8-10}+${disp-6}]")
     (+ (f-b14-15 0) disp-6 (f-s-11 0) rs-8-10 rd-4-7)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI disp-6)))
       (set rd-4-7 (mem USI eff-addr)))
     ()
)

(dni (ldwmemrev)
     ("ldw @[rs+disp:6],rd")
     ()
     ("ldw @[${rs-8-10}+${disp-6}],${rd-4-7}")
     (+ (f-b14-15 0) disp-6 (f-s-11 1) rs-8-10 rd-4-7)
     (sequence ((USI eff-addr))
       (set eff-addr (add rs-8-10 (zext USI disp-6)))
       (set (mem USI eff-addr) rd-4-7))
     ()
)

(dnmi stwmemrev "stw @[rs+disp:6],rd"
     (NO-DIS)
     ("stw @[${rs-8-10}+${disp-6}],${rd-4-7}")
     (emit ldwmemrev rs-8-10 disp-6 rd-4-7)
)

(dni (mul)
     ("mul rd,rs")
     ()
     ("mul${sssd} ${rd-8-10},${rs-0-2}")
     (+ OP1_8 sssd rd-8-10 OP3_B rs-0-2)
     (sequence ((SI left) (SI right))
       (set left (if SI (and sssd 2)       ; sd
         (ext SI (trunc HI rd-8-10))
         (zext SI (trunc HI rd-8-10))))
       (set right (if SI (and sssd 1)      ; ss
         (ext SI (trunc HI rs-0-2))
         (zext SI (trunc HI rs-0-2))))
       (set rd-8-10 (mul SI right left)))
     ()
)

(dni (nop)
     ("nop")
     ()
     ("nop")
     (+ OP1_9 OP2_E OP3_4 OP4_E)
     (nop)
     ()
)

(dni (orimm)
     ("or r0,#imm:8")
     ()
     ("or r0,#${imm-8}")
     (+ OP1_9 OP2_5 imm-8)
     (sequence ((SI result))
       (set result (or (reg h-r 0) (zext SI imm-8)))
       (set tbit (eq result 0))
       (set (reg h-r 0) result))
     ()
)

(dni (or)
     ("or rd,rs")
     ()
     ("or ${rd-8-11},${rs-0-3}")
     (+ OP1_8 rd-8-11 OP3_3 rs-0-3)
     (sequence ((SI result))
       (set result (or rd-8-11 rs-0-3))
       (set tbit (eq result 0))
       (set rd-8-11 result)
       (set-z rd-8-11))
     ()
)

(dni (pop)
     ("pop rd")
     ()
     ("pop ${rd-0-3}")
     (+ OP1_9 OP2_C OP3_0 rd-0-3)
     (sequence ((SI temp))
       (set temp (add (reg h-r 15) 4))
       (set rd-0-3 (mem SI (reg h-r 15)))
       (set (reg h-r 15) temp))
     ()
)

(dni (popmulti)
     ("pop qq")
     ()
     ("pop $qq")
     (+ OP1_9 OP2_C OP3_2 qq (f-b0-1 0))
     (sequence ((SI temp))
       (set temp (add (reg h-r 15) 16))
       (set (reg h-r (mul qq 4)) (mem SI (reg h-r 15)))
       (set (reg h-r (add 1 (mul qq 4))) (mem SI (add 4 (reg h-r 15))))
       (set (reg h-r (add 2 (mul qq 4))) (mem SI (add 8 (reg h-r 15))))
       (set (reg h-r (add 3 (mul qq 4))) (mem SI (add 12 (reg h-r 15))))
       (set (reg h-r 15) temp))
     ()
)

(dni (push)
     ("push rd")
     ()
     ("push ${rs-0-3}")
     (+ OP1_9 OP2_C OP3_1 rs-0-3)
     (sequence ((SI temp))
       (set temp (sub (reg h-r 15) 4))
       (set (reg h-r 15) temp)
       (set (mem SI (reg h-r 15)) rd-0-3))
     ()
)

(dni (pushmulti)
     ("push qq")
     ()
     ("push $qq")
     (+ OP1_9 OP2_C OP3_3 qq (f-b0-1 3))
     (sequence ((SI temp))
       (set temp (sub (reg h-r 15) 16))
       (set (mem SI (sub (reg h-r 15) 4)) (reg h-r (add 3 (mul qq 4))))
       (set (mem SI (sub (reg h-r 15) 8)) (reg h-r (add 2 (mul qq 4))))
       (set (mem SI (sub (reg h-r 15) 12)) (reg h-r (add 1 (mul qq 4))))
       (set (mem SI (sub (reg h-r 15) 16)) (reg h-r (mul qq 4)))
       (set (reg h-r 15) temp))
     ()
)

(dni (ret_expt)
     ("ret_expt")
     ()
     ("ret_expt")
     (+ OP1_9 OP2_F OP3_4 OP4_3)
     (sequence ()
       (set sr ssr_expt)
       (set pc spc_expt))
     ()
)

(dni (ret_fiq)
     ("ret_fiq")
     ()
     ("ret_fiq")
     (+ OP1_9 OP2_F OP3_4 OP4_0)
     (sequence ()
       (set sr ssr_fiq)
       (set pc spc_fiq))
     ()
)

(dni (ret_irq)
     ("ret_irq")
     ()
     ("ret_irq")
     (+ OP1_9 OP2_F OP3_4 OP4_1)
     (sequence ()
       (set sr ssr_irq)
       (set pc spc_irq))
     ()
)

(dni (ret_swi)
     ("ret_swi")
     ()
     ("ret_swi")
     (+ OP1_9 OP2_F OP3_4 OP4_2)
     (sequence ()
       (set sr ssr_swi)
       (set pc spc_swi))
     ()
)

(dni (rl1)
     ("rl1 rd")
     ()
     ("rl1 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_8 rd-0-3)
     (sequence ((SI result))
       (set result (rol rd-0-3 1))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (rrimm)
     ("rrN rd")
     ()
     ("rr${imm-3} ${rd-0-3}")
     (+ OP1_9 OP2_3 (f-bit-7 1) imm-3 rd-0-3)
     (sequence ((SI result))
       (set result (ror rd-0-3 (if SI (eq imm-3 0) 8 imm-3)))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (rr16)
     ("rr16 rd")
     ()
     ("rr16 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_F rd-0-3)
     (sequence ((SI result))
       (set result (ror rd-0-3 16))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (rr)
     ("rr rd,rs")
     ()
     ("rr ${rd-0-3},${rs-4-6}")
     (+ OP1_9 OP2_B (f-bit-7 1) rs-4-6 rd-0-3)
     (sequence ((SI result))
       (set result (ror rd-0-3 (and rs-4-6 31)))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (rrc1)
     ("rrc1 rd")
     ()
     ("rrc1 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_B rd-0-3)
     (sequence ((SI result) (SI tmp))
       (set tmp tbit)
       (set result (or (sll tmp 31) (srl rd-0-3 1)))
       (set tbit (and rd-0-3 1))
       (set rd-0-3 result))
     ()
)

(define-pmacro (sub-op name comment syntax format src extra)
  (begin
    (dni (name)
         (comment)
         ()
         (syntax)
         format
         (sequence ((SI result))
           (set result (subc rd-8-11 src extra))
           (set tbit (sub-cflag SI rd-8-11 src extra))
           (set vbit (sub-oflag SI rd-8-11 src extra))
           (set rd-8-11 result)
           (set-z rd-8-11))
         ()
    )
  )
)

; sub with carry
(sub-op sbc
     "sbc rd,rs"
     "sbc ${rd-8-11},${rs-0-3}"
     (+ OP1_8 rd-8-11 OP3_5 rs-0-3)
     rs-0-3 (not tbit)
)

(dni (setsr)
     ("setsr bs:5")
     ()
     ("setsr ${bs-5}")
     (+ OP1_9 OP2_E (f-b5-7 4) bs-5)
     (cond
       ((eq bs-5 0) (set tbit 1))
       ((eq bs-5 3) (set vbit 1))
       ((eq bs-5 4) (set z0bit 1))
       ((eq bs-5 5) (set z1bit 1))
       ((eq bs-5 6) (set dsbit 1))
       ((eq bs-5 7) (set qtbit 1))
       ((eq bs-5 12) (set bxbit 1))
       ((eq bs-5 13) (set hxbit 1))
       ((eq bs-5 16) (set sysx (or sysx (const #x1))))
       ((eq bs-5 17) (set sysx (or sysx (const #x2))))
       ((eq bs-5 18) (set sysx (or sysx (const #x4))))
       ((eq bs-5 19) (set sysx (or sysx (const #x8))))
       ((eq bs-5 24) (set iebit 1))
       ((eq bs-5 25) (set febit 1))
       ((eq bs-5 26) (set tebit 1))
       ((eq bs-5 28) (set bsbit 1))
       ((eq bs-5 29) (set rs0bit 1))
       ((eq bs-5 30) (set rs1bit 1))
       ((eq bs-5 31) (set pmbit 1)))
     ()
)

(dni (sextbh)
     ("sextb/h rd")
     ()
     ("sext${H-4} ${rd-0-3}")
     (+ OP1_9 OP2_1 (f-b5-7 1) H-4 rd-0-3)
     (sequence ((SI tmp))
       (set tmp (if SI H-4 (trunc HI rd-0-3) (trunc QI rd-0-3)))
       (set rd-0-3 (ext SI tmp)))
     ()
)

(dni (slimm)
     ("slN rd")
     ()
     ("sl${imm-3} ${rd-0-3}")
     (+ OP1_9 OP2_2 (f-bit-7 0) imm-3 rd-0-3)
     (sequence ((SI result) (SI tmp))
       (set tmp (if SI (eq imm-3 0) 8 imm-3))
       (set result (sll rd-0-3 tmp))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (sl16)
     ("sl16 rd")
     ()
     ("sl16 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_C rd-0-3)
     (sequence ((SI result))
       (set result (sll rd-0-3 16))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (sl)
     ("sl rd,rs")
     ()
     ("sl ${rd-0-3},${rs-4-6}")
     (+ OP1_9 OP2_A (f-bit-7 0) rs-4-6 rd-0-3)
     (sequence ((SI result))
       (set result (sll rd-0-3 (and rs-4-6 #x1f)))
       (set tbit (and (const #x80000000) result))
       (set rd-0-3 result))
     ()
)

(dni (srimm)
     ("srN rd")
     ()
     ("sr${imm-3} ${rd-0-3}")
     (+ OP1_9 OP2_2 (f-bit-7 1) imm-3 rd-0-3)
     (sequence ((SI result) (SI tmp))
       (set tmp (if SI (eq imm-3 0) 8 imm-3))
       (set result (srl rd-0-3 tmp))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (sr16)
     ("sr16 rd")
     ()
     ("sr16 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_D rd-0-3)
     (sequence ((SI result))
       (set result (srl rd-0-3 16))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (sr)
     ("sr rd,rs")
     ()
     ("sr ${rd-0-3},${rs-4-6}")
     (+ OP1_9 OP2_A (f-bit-7 1) rs-4-6 rd-0-3)
     (sequence ((SI result))
       (set result (srl rd-0-3 (and rs-4-6 #x1f)))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (sraimm)
     ("sraN rd")
     ()
     ("sra${imm-3} ${rd-0-3}")
     (+ OP1_9 OP2_3 (f-bit-7 0) imm-3 rd-0-3)
     (sequence ((SI result) (SI tmp))
       (set tmp (if SI (eq imm-3 0) 8 imm-3))
       (set result (sra rd-0-3 tmp))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (sra16)
     ("sra16 rd")
     ()
     ("sra16 ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_E rd-0-3)
     (sequence ((SI result))
       (set result (sra rd-0-3 16))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

(dni (sra)
     ("sra rd,rs")
     ()
     ("sra ${rd-0-3},${rs-4-6}")
     (+ OP1_9 OP2_B (f-bit-7 0) rs-4-6 rd-0-3)
     (sequence ((SI result))
       (set result (sra rd-0-3 (and rs-4-6 #x1f)))
       (set tbit (and 1 result))
       (set rd-0-3 result))
     ()
)

; sub with immediate
(sub-op subimm
     "sub rd,#imm:7"
     "sub ${rd-8-11},#${imm-7}"
     (+ OP1_A rd-8-11 (f-bit-7 1) imm-7)
     (zext USI imm-7) (const 0)
)

; sub
(sub-op sub
     "sub rd,rs"
     "sub ${rd-8-11},${rs-0-3}"
     (+ OP1_8 rd-8-11 OP3_1 rs-0-3)
     rs-0-3 (const 0)
)

(dni (swapb)
     ("swapb rd")
     ()
     ("swapb ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_4 rd-0-3)
     (sequence ((UQI byte0) (UQI byte1))
       (set byte0 (and rd-0-3 #xff))
       (set byte1 (and (srl rd-0-3 8) #xff))
       (set rd-0-3 (or (and rd-0-3 #xffff0000) (or (sll byte0 8) byte1))))
     ()
)

(dni (swi)
     ("swi swi_no")
     ()
     ("swi $swi_no")
     (+ OP1_9 OP2_F OP3_6 swi_no)
     (sequence ((USI target))
       (set target (or vbr (or #x100 (sll (and swi_no 15) 4))))
       (set ssr_swi sr)
       (set spc_swi (add pc 2))
       (set pmbit 1)
       (set iebit 0)
       (set pc target))
     ()
)

(dni (sys)
     ("sys imm:5")
     ()
     ("sys ${imm-5}")
     (+ OP1_9 OP2_E (f-b5-7 0) imm-5)
     ; sys isn't really described in the manual, use it for break traps
     (c-call VOID "do_sys" imm-5)
     ()
)

(dni (tstimm)
     ("tst r0,#imm:8")
     ()
     ("tst r0,#${imm-8}")
     (+ OP1_9 OP2_6 imm-8)
     (set tbit (eq (and (reg h-r 0) (zext SI imm-8)) 0))
     ()
)

(dni (tst)
     ("tst rd,rs")
     ()
     ("tst ${rd-8-11},${rs-0-3}")
     (+ OP1_8 rd-8-11 OP3_6 rs-0-3)
     (set tbit (eq (and rd-8-11 rs-0-3) 0))
     ()
)

(dni (tstsr)
     ("tstsr bs:5")
     ()
     ("tstsr ${bs-5}")
     (+ OP1_9 OP2_E (f-b5-7 6) bs-5)
     (set tbit (ne 0 (cond BI
       ((eq bs-5 0) tbit)
       ((eq bs-5 3) vbit)
       ((eq bs-5 4) z0bit)
       ((eq bs-5 5) z1bit)
       ((eq bs-5 6) dsbit)
       ((eq bs-5 7) qtbit)
       ((eq bs-5 12) bxbit)
       ((eq bs-5 13) hxbit)
       ((eq bs-5 16) (and sysx (const #x1)))
       ((eq bs-5 17) (srl (and sysx (const #x2)) 1))
       ((eq bs-5 18) (srl (and sysx (const #x4)) 2))
       ((eq bs-5 19) (srl (and sysx (const #x8)) 3))
       ((eq bs-5 24) iebit)
       ((eq bs-5 25) febit)
       ((eq bs-5 26) tebit)
       ((eq bs-5 28) bsbit)
       ((eq bs-5 29) rs0bit)
       ((eq bs-5 30) rs1bit)
       ((eq bs-5 31) pmbit)
       (else 0))))
     ()
)

(dni (xorimm)
     ("xor r0,#imm:8")
     ()
     ("xor r0,#${imm-8}")
     (+ OP1_9 OP2_7 imm-8)
     (sequence ((SI result))
       (set result (xor (reg h-r 0) (zext SI imm-8)))
       (set tbit (eq result 0))
       (set (reg h-r 0) result))
     ()
)

(dni (xor)
     ("xor rd,rs")
     ()
     ("xor ${rd-8-11},${rs-0-3}")
     (+ OP1_8 rd-8-11 OP3_7 rs-0-3)
     (sequence ((SI result))
       (set result (xor rd-8-11 rs-0-3))
       (set tbit (eq result 0))
       (set rd-8-11 result)
       (set-z rd-8-11))
     ()
)

(dni (zextb)
     ("zextb rd")
     ()
     ("zextb ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_0 rd-0-3)
     (set rd-0-3 (and (const #xff) (trunc QI rd-0-3)))
     ()
)

(dni (zexth)
     ("zexth rd")
     ()
     ("zexth ${rd-0-3}")
     (+ OP1_9 OP2_1 OP3_1 rd-0-3)
     (set rd-0-3 (and (const #xffff) (trunc HI rd-0-3)))
     ()
)


